{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Roughness","text":"<p>A python package for predicting the emission from a rough planetary surface.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT open license. See Zenodo for citation information.</p>"},{"location":"about/","title":"About","text":"<p>The roughness Python package is adapted from code by the late Dr. J. L. Bandfield. You can read more about the first iterations of this code in Bandfield et al. (2015) and Bandfield et al. (2018).</p>"},{"location":"about/#publications","title":"Publications","text":"<p>The roughness thermophysical model presented here has been used in the following publications:</p> <ul> <li>Tai Udovicic (2022) PhD Dissertation</li> <li>Farrand et al. (2022) Icarus</li> </ul>"},{"location":"about/#bug-reports-feature-requests","title":"Bug reports &amp; feature requests","text":"<p>We appreciate any and all contributions in the form of bug reports &amp; feature requests on our issues tracker.</p>"},{"location":"gen_api_pages/","title":"Gen api pages","text":"In\u00a0[1]: Copied! <pre>\"\"\"Generate the code reference pages.\"\"\"\n</pre> \"\"\"Generate the code reference pages.\"\"\" Out[1]: <pre>'Generate the code reference pages.'</pre> In\u00a0[2]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[3]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[4]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[5]: Copied! <pre>for path in sorted(Path(\"roughness\").rglob(\"*.py\")):\n    if path.name in [\"__init__.py\", \"config.py\", \"cli.py\"]:\n        continue\n\n    module_path = path.relative_to(\"roughness\").with_suffix(\"\")\n    doc_path = path.relative_to(\"roughness\").with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = list(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        identifier = \".\".join(parts)\n        print(\"::: \" + identifier, file=fd)\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"../\") / path)\n</pre> for path in sorted(Path(\"roughness\").rglob(\"*.py\")):     if path.name in [\"__init__.py\", \"config.py\", \"cli.py\"]:         continue      module_path = path.relative_to(\"roughness\").with_suffix(\"\")     doc_path = path.relative_to(\"roughness\").with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = list(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         identifier = \".\".join(parts)         print(\"::: \" + identifier, file=fd)      mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"../\") / path) In\u00a0[6]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"getting_started/","title":"Getting Started","text":"<p>The roughness python model requires 3 components to run:</p> <ul> <li>The package itself (see installation instructions)</li> <li>A raytrace shadowing lookup table (see make_los_table)</li> <li>A temperature lookup table (see Temperature Tables)</li> </ul> <p>Basic versions of the generaic shadowing table and lunar temperature lookup table are provided on Zenodo (coming soon), but custom versions of each can be generated using the tools in the roughness package.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The roughness package can be installed using pip:</p> <pre><code>pip install roughness\n</code></pre>"},{"location":"getting_started/#roughness-workflow","title":"Roughness workflow","text":"<p>The roughness thermophysical model requires 3 main components:</p> <ol> <li>The <code>roughness</code> python` package</li> <li>A raytracing shadowing lookup table</li> <li>A surface temperature lookup table</li> </ol> <p>The <code>roughness</code> package can fetch pre-generated shadowing and temperature lookup tables that were derived and validated for the Moon. Custom shadowing tables can be generated using the roughness package, and custom surface temperature tables can be generated with an arbitrary thermal model (but must be saved in xarray-readable format).</p>"},{"location":"getting_started/#downloading-the-lookup-tables","title":"Downloading the lookup tables","text":"<p>With roughness installed, download the pre-generated lunar shadowing and tempeature lookup tables with:</p> <pre><code>roughness -d\n</code></pre> <p>Calling this command again will check for updates and download new tables only if an update is available.</p>"},{"location":"getting_started/#running-the-roughness-thermophysical-model","title":"Running the roughness thermophysical model","text":"<p>The roughness thermophysical model can be run from Python by importing the <code>RoughnessThermalModel</code> object from the roughness package and supplying the required geometry:</p> <pre><code>from roughness import RoughnessThermalModel\nrtm = RoughnessThermalModel()  # Init with default lookup tables\ngeometry = (30, 0, 60, 0)  # inc, inc_az, emit, emit_az [degrees]\nwavelengths = np.arange(1, 100)  # [microns]\nrms = 25  # RMS roughness [degrees]\nprint(rtm.required_tparams)\n# {'albedo', 'lat', 'ls', 'tloc'}\ntparams = {'albedo': 0.12, 'lat': 0, 'ls': 0, 'tloc': 12}  # temp table params\nemission = rtm.emission(geometry, wavelengths, rms, tparams)  # returns xarray\nemission.plot() # Plot emitted radiance vs. wavelength\n</code></pre> <p>See Rough Emission for a more detailed example.</p>"},{"location":"rough_emission/","title":"Rough Emission","text":"In\u00a0[1]: Copied! <pre>from roughness import RoughnessThermalModel\n\n# Create a model instance\nrtm = RoughnessThermalModel()\nrtm\n</pre> from roughness import RoughnessThermalModel  # Create a model instance rtm = RoughnessThermalModel() rtm Out[1]: <pre>RoughnessThermalModel(shadow_lookup='/home/runner/work/roughness/roughness/data/default_lookup.nc', temperature_lookup='/home/runner/work/roughness/roughness/data/temp_lookup_moon.nc')</pre> In\u00a0[2]: Copied! <pre>rtm.temperature_ds\n</pre> rtm.temperature_ds Out[2]: <pre>&lt;xarray.Dataset&gt;\nDimensions:  (albedo: 6, lat: 18, theta: 19, ls: 10, tloc: 37, az: 19)\nCoordinates:\n  * albedo   (albedo) float64 0.05 0.085 0.12 0.155 0.19 0.225\n  * lat      (lat) float64 -85.0 -75.0 -65.0 -55.0 -45.0 ... 55.0 65.0 75.0 85.0\n  * theta    (theta) float64 0.0 5.0 10.0 15.0 20.0 ... 70.0 75.0 80.0 85.0 90.0\n  * ls       (ls) float64 0.0 40.0 80.0 120.0 160.0 ... 240.0 280.0 320.0 360.0\n  * tloc     (tloc) float64 0.0 0.6667 1.333 2.0 2.667 ... 22.0 22.67 23.33 24.0\n  * az       (az) float64 0.0 20.0 40.0 60.0 80.0 ... 300.0 320.0 340.0 360.0\nData variables:\n    tsurf    (albedo, lat, ls, az, theta, tloc) float32 ...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>albedo: 6</li><li>lat: 18</li><li>theta: 19</li><li>ls: 10</li><li>tloc: 37</li><li>az: 19</li></ul></li><li>Coordinates: (6)<ul><li>albedo(albedo)float640.05 0.085 0.12 0.155 0.19 0.225<pre>array([0.05 , 0.085, 0.12 , 0.155, 0.19 , 0.225])</pre></li><li>lat(lat)float64-85.0 -75.0 -65.0 ... 75.0 85.0<pre>array([-85., -75., -65., -55., -45., -35., -25., -15.,  -5.,   5.,  15.,  25.,\n        35.,  45.,  55.,  65.,  75.,  85.])</pre></li><li>theta(theta)float640.0 5.0 10.0 ... 80.0 85.0 90.0<pre>array([ 0.,  5., 10., 15., 20., 25., 30., 35., 40., 45., 50., 55., 60., 65.,\n       70., 75., 80., 85., 90.])</pre></li><li>ls(ls)float640.0 40.0 80.0 ... 280.0 320.0 360.0<pre>array([  0.,  40.,  80., 120., 160., 200., 240., 280., 320., 360.])</pre></li><li>tloc(tloc)float640.0 0.6667 1.333 ... 23.33 24.0<pre>array([ 0.      ,  0.666667,  1.333333,  2.      ,  2.666667,  3.333333,\n        4.      ,  4.666667,  5.333333,  6.      ,  6.666667,  7.333333,\n        8.      ,  8.666667,  9.333334, 10.      , 10.666667, 11.333334,\n       12.      , 12.666667, 13.333334, 14.      , 14.666667, 15.333334,\n       16.      , 16.666668, 17.333334, 18.      , 18.666668, 19.333334,\n       20.      , 20.666668, 21.333334, 22.      , 22.666668, 23.333334,\n       24.      ])</pre></li><li>az(az)float640.0 20.0 40.0 ... 320.0 340.0 360.0<pre>array([  0.,  20.,  40.,  60.,  80., 100., 120., 140., 160., 180., 200., 220.,\n       240., 260., 280., 300., 320., 340., 360.])</pre></li></ul></li><li>Data variables: (1)<ul><li>tsurf(albedo, lat, ls, az, theta, tloc)float32...body :Moonk_mode :Fengkrc_version :v3.6.5photo_mode :Vasavadaprocessedby :ctaiudovicic@tintounits :K<pre>[14425560 values with dtype=float32]</pre></li></ul></li><li>Indexes: (6)<ul><li>albedoPandasIndex<pre>PandasIndex(Index([0.05, 0.085, 0.12, 0.155, 0.19, 0.225], dtype='float64', name='albedo'))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([-85.0, -75.0, -65.0, -55.0, -45.0, -35.0, -25.0, -15.0,  -5.0,   5.0,\n        15.0,  25.0,  35.0,  45.0,  55.0,  65.0,  75.0,  85.0],\n      dtype='float64', name='lat'))</pre></li><li>thetaPandasIndex<pre>PandasIndex(Index([ 0.0,  5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0,\n       60.0, 65.0, 70.0, 75.0, 80.0, 85.0, 90.0],\n      dtype='float64', name='theta'))</pre></li><li>lsPandasIndex<pre>PandasIndex(Index([0.0, 40.0, 80.0, 120.0, 160.0, 200.0, 240.0, 280.0, 320.0, 360.0], dtype='float64', name='ls'))</pre></li><li>tlocPandasIndex<pre>PandasIndex(Index([               0.0, 0.6666666865348816, 1.3333333730697632,\n                      2.0, 2.6666667461395264, 3.3333334922790527,\n                      4.0, 4.6666669845581055,  5.333333492279053,\n                      6.0, 6.6666669845581055,  7.333333492279053,\n                      8.0,  8.666666984558105,  9.333333969116211,\n                     10.0, 10.666666984558105, 11.333333969116211,\n                     12.0, 12.666666984558105, 13.333333969116211,\n                     14.0, 14.666666984558105, 15.333333969116211,\n                     16.0, 16.666667938232422,  17.33333396911621,\n                     18.0, 18.666667938232422,  19.33333396911621,\n                     20.0, 20.666667938232422,  21.33333396911621,\n                     22.0, 22.666667938232422,  23.33333396911621,\n                     24.0],\n      dtype='float64', name='tloc'))</pre></li><li>azPandasIndex<pre>PandasIndex(Index([  0.0,  20.0,  40.0,  60.0,  80.0, 100.0, 120.0, 140.0, 160.0, 180.0,\n       200.0, 220.0, 240.0, 260.0, 280.0, 300.0, 320.0, 340.0, 360.0],\n      dtype='float64', name='az'))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>The <code>roughness</code> thermal model interpolates between the pre-computed shadowing and lookup tables to compute the emitted radiance for a given geometry and local conditions. The desired parameters are passed to the <code>emission</code> method of the <code>RoughnessThermalModel</code> object, which returns an <code>xarray</code> object containing the emitted radiance for each wavelength and roughness value. The <code>emission</code> method requires the following parameters:</p> <ul> <li><code>geometry</code>: A tuple containing the solar incidence angle, solar azimuth, spacecraft emission angle, and spacecraft azimuth, all in units of degrees. Azimuths are computed clockwise from North.</li> <li><code>wavelengths</code>: An array of wavelengths in units of microns where emission will be computed.</li> <li><code>rms</code>: The RMS roughness in units of degrees.</li> <li><code>tparams</code>: A dictionary containing the parameters required to interpolate the temperature lookup table. The required parameters are all coordinates of <code>rtm.temperature_ds</code> except for facet <code>theta</code> and <code>az</code>. Print <code>rtm.required_tparams</code> to check which parameters are needed.</li> <li><code>kwargs</code>: Additional keyword arguments are passed to <code>roughness.emission.rough_emission_lookup</code> to fine tune the emission run. See emission for more details.</li> </ul> In\u00a0[3]: Copied! <pre>rtm.required_tparams\n</pre> rtm.required_tparams Out[3]: <pre>{'albedo', 'lat', 'ls', 'tloc'}</pre> In\u00a0[4]: Copied! <pre>import numpy as np\nfrom roughness import helpers as rh\n\n# Set parameters\nrms = 15\nwls = np.linspace(0.45, 100, 1000)\nsun_theta, sun_az = 30, 90\nsc_theta, sc_az = 60, 90\nlat = 0  # Latitude [degrees]\nls = 0  # Solar longitude (L_s) [degrees]\nalbedo = 0.12  # Directional hemispherical (thermal) albedo\n\n# Compute tloc and set tparams\ntloc = rh.inc_to_tloc(sun_theta, sun_az, lat)\ntparams = {'albedo': albedo, 'lat': lat, 'ls': ls, 'tloc': tloc}\n\n# Compute rough emission\nemission = rtm.emission(sun_theta, sun_az, sc_theta, sc_az, wls, rms, tparams)\n\nemission.plot()\n</pre> import numpy as np from roughness import helpers as rh  # Set parameters rms = 15 wls = np.linspace(0.45, 100, 1000) sun_theta, sun_az = 30, 90 sc_theta, sc_az = 60, 90 lat = 0  # Latitude [degrees] ls = 0  # Solar longitude (L_s) [degrees] albedo = 0.12  # Directional hemispherical (thermal) albedo  # Compute tloc and set tparams tloc = rh.inc_to_tloc(sun_theta, sun_az, lat) tparams = {'albedo': albedo, 'lat': lat, 'ls': ls, 'tloc': tloc}  # Compute rough emission emission = rtm.emission(sun_theta, sun_az, sc_theta, sc_az, wls, rms, tparams)  emission.plot() Out[4]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f871d455100&gt;]</pre> In\u00a0[5]: Copied! <pre>from roughness import emission as re\n\n# Convert emitted radiance to brightness temperature\nbtemp = re.btempw(wls, re.mrad2cmrad(emission))\nbtemp.name = \"Brightness Temperature [K]\"\n\n# Plot\nbtemp.plot()\n</pre> from roughness import emission as re  # Convert emitted radiance to brightness temperature btemp = re.btempw(wls, re.mrad2cmrad(emission)) btemp.name = \"Brightness Temperature [K]\"  # Plot btemp.plot() Out[5]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f871d3a38b0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"rough_emission/#rough-emission","title":"Rough Emission\u00b6","text":"<p>This worked example shows how to use <code>roughness</code> to compute a radiated emission spectrum from a rough surface.</p>"},{"location":"rough_emission/#setup","title":"Setup\u00b6","text":"<p>Make sure to install the <code>roughness</code> package and download the default lookup tables before running this example. See the getting started page for more information.</p>"},{"location":"rough_emission/#imports","title":"Imports\u00b6","text":"<p>The <code>roughness</code> package provides a <code>RoughnessThermalModel</code> class that can be used to compute emission spectra from rough surfaces. The <code>xarray</code> package is used to store and manipulate the lookup tables.</p>"},{"location":"rough_emission/#custom-lookup-tables","title":"Custom Lookup Tables\u00b6","text":"<p>The default lookup tables have been developed and tested for the Moon. However, <code>roughness</code> allows users to generate custom lookup tables for any body with a custom thermal model.</p> <p>The <code>shadow_lookup</code> table is a lookup table of probabilities that a given surface facet is in shadow. It is generated using a raytracing algorithm applied to a self-affine fractal rough surface with a default Hurst exponent chosen for lunar applications. The default surface should function for most rough planetary surfaces, but can be regenerated ysing the <code>roughness.make_los_table</code> module as described in shadow_tables.</p> <p>The <code>temperature_lookup</code> table is a lookup table of surface temperatures for each surface facet. Any thermal model can be used to generate this table and it can have arbitrary dimensionality, the only requirement is that the output is an <code>xarray.Dataset</code> with a data variable <code>tsurf</code> and contains at least the <code>theta</code> and <code>az</code> coordinates, corresponding to surface facet slope and azimuth.</p> <p>The default temperature table used in <code>roughness</code> was developed for the Moon using KRC (krc.mars.asu.edu) and is body-specific due to the unique thermal environment of each planetary body. Below is the temperature Dataset with coordinates relevant to predicting surface temperatures on the Moon. See temperature_tables for more details.</p>"},{"location":"rough_emission/#predicting-emission","title":"Predicting emission\u00b6","text":"<p>We can now use the roughness model to predict the emission from a surface with a given roughness. We'll use an RMS value of 25 degrees and pick a point near the equator. We use a helper function to compute the local time at the chosen point.</p>"},{"location":"rough_emission/#plotting-brightness-tempertures","title":"Plotting brightness tempertures\u00b6","text":""},{"location":"shadow_tables/","title":"Shadow table","text":""},{"location":"shadow_tables/#shadow-table","title":"Shadow table\u00b6","text":"<p>Coming soon...</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>classes</li> <li>diviner</li> <li>emission</li> <li>helpers</li> <li>m3_correction</li> <li>make_los_table</li> <li>plotting</li> <li>roughness</li> </ul>"},{"location":"reference/classes/","title":"classes","text":"<p>This file contains the shadow lookup and temperature lookup classes that are used by the roughness thermal model.</p>"},{"location":"reference/classes/#classes.RoughnessThermalModel","title":"<code>RoughnessThermalModel</code>","text":"<p>Initialize a roughness thermophysical model object.</p> Source code in <code>roughness/classes.py</code> <pre><code>class RoughnessThermalModel:\n\"\"\"Initialize a roughness thermophysical model object.\"\"\"\n\n    def __init__(self, shadow_lookup=FLOOKUP, temperature_lookup=TLOOKUP):\n        if shadow_lookup == FLOOKUP and not Path(shadow_lookup).exists():\n            raise FileNotFoundError(\n                \"Default shadow lookup table not found. Please run \\\n                `roughness -d` in the terminal to download it.\"\n            )\n        self.shadow_lookup = shadow_lookup\n        self.temperature_lookup = temperature_lookup\n        self.temperature_ds = xr.open_dataset(temperature_lookup)\n        if not {\"theta\", \"az\"}.issubset(self.temperature_ds.dims):\n            raise ValueError(\n                f\"Temperature lookup {self.temperature_lookup} \\\n                               must have dimensions az, theta\"\n            )\n\n    def __repr__(self):\n        return (f\"RoughnessThermalModel(shadow_lookup='{self.shadow_lookup}'\" +\n                f\", temperature_lookup='{self.temperature_lookup}')\")\n\n    def emission(\n        self, sun_theta, sun_az, sc_theta, sc_az, wls, rms, tparams, **kwargs\n    ):\n\"\"\"\n        Return rough surface emission at the given viewing geometry.\n\n        Parameters:\n            sun_theta,sun_az,sc_theta,sc_az (num): Viewing angles [degrees]\n                (incidence, solar_azimuth, emergence, emergence_azimuth)\n            wls (arr): Wavelengths [microns]\n            rms (arr, optional): RMS roughness [degrees]. Default is 15.\n            rerad (bool, optional): If True, include re-radiation from adjacent\n                facets. Default is True.\n            tparams (dict, optional): Dictionary of temp erature lookup parameters.\n                Default is None.\n            **kwargs\n\n        Returns:\n            (xr.DataArray): Rough emission spectrum.\n\n        \"\"\"\n        if tparams.keys() != self.required_tparams:\n            raise ValueError(f\"Tparams must contain {self.required_tparams}\")\n        args = ((sun_theta, sun_az, sc_theta, sc_az), wls, rms, tparams)\n        return re.rough_emission_lookup(*args, **kwargs)\n\n    @cached_property\n    def required_tparams(self):\n\"\"\"Check which tparams are required by the TemperatureLookup.\"\"\"\n        return set(self.temperature_ds.dims) - {\"theta\", \"az\"}\n</code></pre>"},{"location":"reference/classes/#classes.RoughnessThermalModel.required_tparams","title":"<code>required_tparams</code>  <code>cached</code> <code>property</code>","text":"<p>Check which tparams are required by the TemperatureLookup.</p>"},{"location":"reference/classes/#classes.RoughnessThermalModel.emission","title":"<code>emission(sun_theta, sun_az, sc_theta, sc_az, wls, rms, tparams, **kwargs)</code>","text":"<p>Return rough surface emission at the given viewing geometry.</p> <p>Parameters:</p> Name Type Description Default <code>sun_theta,sun_az,sc_theta,sc_az</code> <code>num</code> <p>Viewing angles [degrees] (incidence, solar_azimuth, emergence, emergence_azimuth)</p> required <code>wls</code> <code>arr</code> <p>Wavelengths [microns]</p> required <code>rms</code> <code>arr</code> <p>RMS roughness [degrees]. Default is 15.</p> required <code>rerad</code> <code>bool</code> <p>If True, include re-radiation from adjacent facets. Default is True.</p> required <code>tparams</code> <code>dict</code> <p>Dictionary of temp erature lookup parameters. Default is None.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Rough emission spectrum.</p> Source code in <code>roughness/classes.py</code> <pre><code>def emission(\n    self, sun_theta, sun_az, sc_theta, sc_az, wls, rms, tparams, **kwargs\n):\n\"\"\"\n    Return rough surface emission at the given viewing geometry.\n\n    Parameters:\n        sun_theta,sun_az,sc_theta,sc_az (num): Viewing angles [degrees]\n            (incidence, solar_azimuth, emergence, emergence_azimuth)\n        wls (arr): Wavelengths [microns]\n        rms (arr, optional): RMS roughness [degrees]. Default is 15.\n        rerad (bool, optional): If True, include re-radiation from adjacent\n            facets. Default is True.\n        tparams (dict, optional): Dictionary of temp erature lookup parameters.\n            Default is None.\n        **kwargs\n\n    Returns:\n        (xr.DataArray): Rough emission spectrum.\n\n    \"\"\"\n    if tparams.keys() != self.required_tparams:\n        raise ValueError(f\"Tparams must contain {self.required_tparams}\")\n    args = ((sun_theta, sun_az, sc_theta, sc_az), wls, rms, tparams)\n    return re.rough_emission_lookup(*args, **kwargs)\n</code></pre>"},{"location":"reference/diviner/","title":"diviner","text":"<p>Helpers for Diviner data.</p>"},{"location":"reference/diviner/#diviner.add_wls_diviner","title":"<code>add_wls_diviner(xarr, bands=('t3', 't4', 't5', 't6', 't7', 't8', 't9'))</code>","text":"<p>Return xarr with wavelength coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>xarr</code> <code>DataArray</code> <p>Diviner lev4 hourly temperature data</p> required <code>bands</code> <code>tuple</code> <p>bands to include in output</p> <code>('t3', 't4', 't5', 't6', 't7', 't8', 't9')</code> Source code in <code>roughness/diviner.py</code> <pre><code>def add_wls_diviner(xarr, bands=(\"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\")):\n\"\"\"\n    Return xarr with wavelength coordinate.\n\n    Parameters:\n        xarr (xr.DataArray): Diviner lev4 hourly temperature data\n        bands (tuple): bands to include in output\n    \"\"\"\n    wl = get_diviner_wls().values\n    out = xarr.sel(band=slice(\"t3\", \"t9\")).assign_coords(\n        wavelength=(\"band\", wl)\n    )\n    out = out.reindex(band=bands)  # Drops unneeded bands\n    return out\n</code></pre>"},{"location":"reference/diviner/#diviner.div_integrated_rad","title":"<code>div_integrated_rad(emission, units='W/m^2/sr/um')</code>","text":"<p>Return integrated radiance of diviner bands.</p> <p>Parameters:</p> Name Type Description Default <code>emission</code> <code>DataArray</code> <p>Diviner radiated emission</p> required <code>units</code> <code>str</code> <p>units of output</p> <code>'W/m^2/sr/um'</code> Source code in <code>roughness/diviner.py</code> <pre><code>def div_integrated_rad(emission, units=\"W/m^2/sr/um\"):\n\"\"\"\n    Return integrated radiance of diviner bands.\n\n    Parameters:\n        emission (xr.DataArray): Diviner radiated emission\n        units (str): units of output\n    \"\"\"\n    out = []\n    for dwlmin, dwlmax in zip(DIV_WL_MIN, DIV_WL_MAX):\n        cemiss = emission.sel(wavelength=slice(dwlmin, dwlmax))\n        wlmin = cemiss.wavelength.min().values\n        wlmax = cemiss.wavelength.max().values\n        out.append(cemiss.integrate(\"wavelength\").values / (wlmax - wlmin))\n    wls = get_diviner_wls().values\n    return rh.spec2xr(out, wls, units=units)\n</code></pre>"},{"location":"reference/diviner/#diviner.div_tbol","title":"<code>div_tbol(divbt, wl1=DIV_WL1, wl2=DIV_WL2, tmin=DIV_TMIN, iters=ITERS)</code>","text":"<p>Return bolometric temperature from Diviner C3-C9 brightness temperatures  (s.o.m, Paige et al., 2010, in Science).</p> <p>Parameters:</p> Name Type Description Default <code>divbt</code> <code>array</code> <p>Diviner brightness temperatures</p> required <code>wl1</code> <code>array</code> <p>lower wavelength bound of each band</p> <code>DIV_WL1</code> <code>wl2</code> <code>array</code> <p>upper wavelength bound of each band</p> <code>DIV_WL2</code> <code>tmin</code> <code>array</code> <p>minimum temperature of each band</p> <code>DIV_TMIN</code> <code>iters</code> <code>array</code> <p>number of iterations for each band</p> <code>ITERS</code> Source code in <code>roughness/diviner.py</code> <pre><code>def div_tbol(divbt, wl1=DIV_WL1, wl2=DIV_WL2, tmin=DIV_TMIN, iters=ITERS):\n\"\"\"\n    Return bolometric temperature from Diviner C3-C9 brightness temperatures \n    (s.o.m, Paige et al., 2010, in Science).\n\n    Parameters:\n        divbt (np.array): Diviner brightness temperatures\n        wl1 (np.array): lower wavelength bound of each band\n        wl2 (np.array): upper wavelength bound of each band\n        tmin (np.array): minimum temperature of each band\n        iters (np.array): number of iterations for each band\n    \"\"\"\n\n    def f(wl, bt, n_iter):\n\"\"\"CFST iteration helper. n_iter small, so loop is faster\"\"\"\n        v = 1.43883e4 / (wl * bt)\n        tot = 0\n        for w in range(1, n_iter + 1):\n            tot += (\n                w**-4\n                * np.e ** -(w * v)\n                * (((w * v + 3) * w * v + 6) * w * v + 6)\n            )\n        return tot\n\n    def cfst(bt, wl1, wl2, n_iter=100):\n\"\"\"\n        Return fraction of Planck radiance between wl1 and wl2 at bt.\n\n        Translated from JB, via DAP via Houghton 'Physics of Atmospheres'\n\n        Parameters:\n            bt (float): brightness temperature\n            wl1 (float): lower wavelength bound\n            wl2 (float): upper wavelength bound\n            n_iter (int): number of iterations\n        \"\"\"\n        return 1.53989733e-1 * (f(wl2, bt, n_iter) - f(wl1, bt, n_iter))\n\n    vcfst = np.vectorize(cfst, otypes=[float])\n\n    # Backfill values below tmin from the next band over (C9-&gt;C3)\n    temp = divbt.copy()\n    for i in range(len(divbt) - 1, -1, -1):\n        if divbt[i] &lt; tmin[i]:\n            temp[i] = temp[i + 1]\n    if (temp &lt;= 0).any():\n        return 0\n    # Convenient to use pandas but overkill, takes longer\n    # temp = (\n    #     pd.Series(np.where(divbt &gt;= tmin, divbt, np.nan))\n    #     .fillna(method=\"bfill\")\n    #     .values\n    # )\n\n    # Convert to radiance, weight by cfst, sum and convert back to temperature\n    rad = re.get_rad_sb(temp) * vcfst(temp, wl1, wl2, iters)\n    tbol = re.get_temp_sb(np.nansum(rad))\n    return tbol\n</code></pre>"},{"location":"reference/diviner/#diviner.divfilt_rad","title":"<code>divfilt_rad(wnrad, div_filt=None)</code>","text":"<p>Return radiance of Diviner bands (convolve rad with Diviner filter funcs).</p> <p>Parameters:</p> Name Type Description Default <code>wnrad</code> <code>DataArray</code> <p>Diviner radiance in wavenumber space</p> required <code>div_filt</code> <code>DataArray</code> <p>Diviner filter functions</p> <code>None</code> Source code in <code>roughness/diviner.py</code> <pre><code>def divfilt_rad(wnrad, div_filt=None):\n\"\"\"\n    Return radiance of Diviner bands (convolve rad with Diviner filter funcs).\n\n    Parameters:\n        wnrad (xr.DataArray): Diviner radiance in wavenumber space\n        div_filt (xr.DataArray): Diviner filter functions\n    \"\"\"\n    if div_filt is None:\n        div_filt = load_div_filters()\n    filtered = div_filt * wnrad  # Must both have wavelength coord\n    return filtered.sum(dim=\"wavelength\") * 2\n</code></pre>"},{"location":"reference/diviner/#diviner.divrad2bt","title":"<code>divrad2bt(divrad, fdiv_t2r=FDIV_T2R)</code>","text":"<p>Return brightness temperatures from Diviner radiance (e.g. from div_filt).</p> <p>Parameters:</p> Name Type Description Default <code>divrad</code> <code>DataArray</code> <p>Diviner radiance</p> required <code>fdiv_t2r</code> <code>str</code> <p>path to Diviner t2r lookup table</p> <code>FDIV_T2R</code> Source code in <code>roughness/diviner.py</code> <pre><code>def divrad2bt(divrad, fdiv_t2r=FDIV_T2R):\n\"\"\"\n    Return brightness temperatures from Diviner radiance (e.g. from div_filt).\n\n    Parameters:\n        divrad (xr.DataArray): Diviner radiance\n        fdiv_t2r (str): path to Diviner t2r lookup table\n    \"\"\"\n    t2r = load_div_t2r(fdiv_t2r)  # cached lookup\n    rad = divrad.values\n    mask = rad &lt; t2r.max(axis=0)\n    rad = np.where(mask, rad, -1)\n    dbt = np.zeros(len(divrad.band.values))\n    for i, c in enumerate(divrad.band.values):\n        # Linearly interpolate between the two closest BT values\n        bt = np.searchsorted(t2r[c], rad[i])\n        if bt == 0:\n            dbt[i] = 0\n        else:\n            f = (rad[i] - t2r[c][bt - 1]) / (t2r[c][bt] - t2r[c][bt - 1])\n            dbt[i] = (bt - 1) * (1 - f) + bt * f\n\n        # np.interp is equivalent but slower\n        # numpy interp(desired x (rad), actual x (rad), actual y (temp))\n        # dbt[i] = np.interp(rad[i], t2r[c], t2r.index)\n    return dbt\n</code></pre>"},{"location":"reference/diviner/#diviner.emission2tbol_xr","title":"<code>emission2tbol_xr(emission, wls=None, div_filt=None)</code>","text":"<p>Return tbol from input emission array at wls.</p> <p>Parameters:</p> Name Type Description Default <code>emission</code> <code>DataArray</code> <p>Diviner radiated emission</p> required <code>wls</code> <code>DataArray</code> <p>wavelengths to integrate over</p> <code>None</code> <code>div_filt</code> <code>DataArray</code> <p>Diviner filter functions</p> <code>None</code> Source code in <code>roughness/diviner.py</code> <pre><code>def emission2tbol_xr(emission, wls=None, div_filt=None):\n\"\"\"\n    Return tbol from input emission array at wls.\n\n    Parameters:\n        emission (xr.DataArray): Diviner radiated emission\n        wls (xr.DataArray): wavelengths to integrate over\n        div_filt (xr.DataArray): Diviner filter functions\n    \"\"\"\n    if wls is None:\n        wls = emission.wavelength\n    elif not isinstance(wls, xr.DataArray):\n        wls = rh.wl2xr(wls)\n    wnrad = re.wlrad2wnrad(wls, emission)\n    divrad = divfilt_rad(wnrad, div_filt)\n    tbol = xr.zeros_like(emission.isel(wavelength=0).drop(\"wavelength\"))\n    dim0, dim1 = tbol.dims  # Generic so that x,y or lat,lon work in any order\n    for i in range(len(tbol[dim0])):\n        for j in range(len(tbol[dim1])):\n            div_bts = divrad2bt(divrad.isel({dim0: i, dim1: j}))\n            tbol[i, j] = div_tbol(div_bts)\n    return tbol\n</code></pre>"},{"location":"reference/diviner/#diviner.fit_poly_daytime","title":"<code>fit_poly_daytime(Tday, deg=2)</code>","text":"<p>Return polynomial fit of order deg to daytime temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>Tday</code> <code>array</code> <p>daytime temperature data</p> required <code>deg</code> <code>int</code> <p>order of polynomial fit</p> <code>2</code> Source code in <code>roughness/diviner.py</code> <pre><code>def fit_poly_daytime(Tday, deg=2):\n\"\"\"\n    Return polynomial fit of order deg to daytime temperature data.\n\n    Parameters:\n        Tday (np.array): daytime temperature data\n        deg (int): order of polynomial fit\n    \"\"\"\n    tloc = np.linspace(6, 18, len(Tday) + 1)[:-1]\n    nan = np.isnan(Tday)\n    pfit = np.polyfit(tloc[~nan], Tday[~nan], deg)\n    fit_func = np.poly1d(pfit)\n    fit = fit_func(tloc)\n    return fit\n</code></pre>"},{"location":"reference/diviner/#diviner.get_diviner_wls","title":"<code>get_diviner_wls(bres=1)</code>","text":"<p>Return diviner c3-c9 wavelength arr with band_res values in each bandpass.</p> <p>Parameters:</p> Name Type Description Default <code>bres</code> <code>int</code> <p>number of wavelength values in each bandpass</p> <code>1</code> Source code in <code>roughness/diviner.py</code> <pre><code>def get_diviner_wls(bres=1):\n\"\"\"\n    Return diviner c3-c9 wavelength arr with band_res values in each bandpass.\n\n    Parameters:\n        bres (int): number of wavelength values in each bandpass\n    \"\"\"\n    if bres == 1:\n        wls = np.mean((DIV_WL_MIN, DIV_WL_MAX), axis=0)\n    else:\n        wzip = zip(DIV_WL_MIN, DIV_WL_MAX)\n        wls = np.array(\n            [np.linspace(w1, w2, bres) for w1, w2 in wzip]\n        ).flatten()\n    return rh.wl2xr(wls)\n</code></pre>"},{"location":"reference/diviner/#diviner.lev4hourly2xr","title":"<code>lev4hourly2xr(fgrds, ext=None, savefile=None, tres=None, interp_method=None, interp_wrap=False)</code>","text":"<p>Return xarray of Diviner lev4 hourly grd tiles with time resolution tres.</p> <p>If interp_method: Interpolate missing values along tloc axis with method specified (e.g. 'nearest', 'linear', 'cubic', see xr.interpolate_na methods). Linear seems to produce fewest sharp artifacts.</p> <p>If savefile: save result to netCDF (.nc) file for quick I/O into xarray, e.g. with xr.open_dataarray(savefile).</p> <p>Parameters:</p> Name Type Description Default <code>fgrds</code> <code>list of str</code> <p>list of paths to .grd files (e.g. from glob)</p> required <code>tres</code> <code>num</code> <p>time resolution</p> <code>None</code> <code>interp_method</code> <code>str</code> <p>interpolation method (see xarray.interpolate_na)</p> <code>None</code> <code>interp_wrap</code> <code>bool</code> <p>interpolate around time axis (wrap around 0/24h)</p> <code>False</code> <code>ext</code> <code>list</code> <p>extent of ROI</p> <code>None</code> <code>savefile</code> <code>str</code> <p>Path to save result to netCDF (.nc) file</p> <code>None</code> Source code in <code>roughness/diviner.py</code> <pre><code>def lev4hourly2xr(\n    fgrds,\n    ext=None,\n    savefile=None,\n    tres=None,\n    interp_method=None,\n    interp_wrap=False,\n):\n\"\"\"\n    Return xarray of Diviner lev4 hourly grd tiles with time resolution tres.\n\n    If interp_method: Interpolate missing values along tloc axis with method\n    specified (e.g. 'nearest', 'linear', 'cubic', see xr.interpolate_na methods).\n    Linear seems to produce fewest sharp artifacts.\n\n    If savefile: save result to netCDF (.nc) file for quick I/O into xarray,\n    e.g. with xr.open_dataarray(savefile).\n\n    Parameters:\n        fgrds (list of str): list of paths to .grd files (e.g. from glob)\n        tres (num): time resolution\n        interp_method (str): interpolation method (see xarray.interpolate_na)\n        interp_wrap (bool): interpolate around time axis (wrap around 0/24h)\n        ext (list): extent of ROI\n        savefile (str): Path to save result to netCDF (.nc) file\n    \"\"\"\n    if not tres:\n        # Assume 8 bands (ch3 - ch9 + tbol), diurnal [24 h], infer tres [hr]\n        tres = 24 / (len(fgrds) / 8)  # [hr]\n    grids = []\n    bands = []\n    for fgrd in fgrds:\n        _, band, ind = Path(fgrd).stem.split(\"-\")\n        tloc = (int(ind) - 1) * tres  # tloc in [0, 24) h\n\n        # Read in .grd and set its local time to tloc\n        grid = xr.open_rasterio(fgrd).sel(band=1)\n        grid[\"tloc\"] = tloc\n        grids.append(grid)\n\n        # Concatenate all local time of this band into single xr.DataArray\n        if tloc == 24 - tres:\n            diurnal_band = xr.concat(grids, dim=\"tloc\")\n            diurnal_band[\"band\"] = band\n            bands.append(diurnal_band)\n            grids = []\n\n    # Concatenate all bands into single 4D xr.DataArray (lon, lat, tloc, band)\n    out = xr.concat(bands, dim=\"band\")\n    out = out.rename(\"Temperature\")\n    out = out.sortby(\n        \"y\", ascending=False\n    )  # TODO: bug doesn't always fix yflip\n\n    # Convert x, y coords to lat, lon\n    if ext is not None:\n        lon, lat = rh.xy2lonlat_coords(out.x, out.y, ext)\n        out = out.rename({\"x\": \"lon\", \"y\": \"lat\"})\n        out = out.assign_coords(lon=lon, lat=lat)\n\n    if interp_method is not None:\n        # Interpolate missing points on tloc\n        if interp_wrap:\n            # Cludgey handling of tloc edges. Wrap full dataset around midnight then interp\n            postmidnight = out.sel(tloc=slice(0, 12 - tres))\n            postmidnight[\"tloc\"] = np.arange(24, 36, tres)\n            premidnight = out.sel(tloc=slice(12, 24 - tres))\n            premidnight[\"tloc\"] = np.arange(-12, 0, tres)\n            out = xr.concat([premidnight, out, postmidnight], dim=\"tloc\")\n        out = out.interpolate_na(\"tloc\", method=interp_method).sel(\n            tloc=slice(0, 24 - tres)\n        )\n\n    if savefile is not None:\n        out.to_netcdf(savefile)\n    return out\n</code></pre>"},{"location":"reference/diviner/#diviner.load_div_filters","title":"<code>load_div_filters(fdiv_filt=FDIV_FILT, scale=True, wlunits=True, bands=DIV_C)</code>  <code>cached</code>","text":"<p>Return Diviner filter functions</p> <p>Parameters:</p> Name Type Description Default <code>fdiv_filt</code> <code>str</code> <p>path to Diviner filter functions</p> <code>FDIV_FILT</code> <code>scale</code> <code>bool</code> <p>scale filter functions by FILT_SCALE</p> <code>True</code> <code>wlunits</code> <code>bool</code> <p>convert wavenumber to wavelength</p> <code>True</code> <code>bands</code> <code>tuple</code> <p>bands to include in output</p> <code>DIV_C</code> Source code in <code>roughness/diviner.py</code> <pre><code>@lru_cache(1)\ndef load_div_filters(\n    fdiv_filt=FDIV_FILT, scale=True, wlunits=True, bands=DIV_C\n):\n\"\"\"\n    Return Diviner filter functions\n\n    Parameters:\n        fdiv_filt (str): path to Diviner filter functions\n        scale (bool): scale filter functions by FILT_SCALE\n        wlunits (bool): convert wavenumber to wavelength\n        bands (tuple): bands to include in output\n    \"\"\"\n    hdf = xr.load_dataset(fdiv_filt)\n    wn = hdf.xaxis.values.squeeze()\n    data = hdf.data.squeeze().values\n    data = data.reshape(data.shape[1], data.shape[0])  # reads wrong axis order\n    div_filt = xr.DataArray(\n        data,\n        name=\"Normalized Response\",\n        dims=[\"wavenumber\", \"band\"],\n        coords={\"band\": list(bands), \"wavenumber\": wn},\n    )\n    if scale:\n        div_filt = div_filt * FILT_SCALE[np.newaxis, :]\n    if wlunits:\n        div_filt.coords[\"wavelength\"] = 10000 / div_filt.wavenumber\n        div_filt = div_filt.swap_dims({\"wavenumber\": \"wavelength\"})\n    return div_filt\n</code></pre>"},{"location":"reference/diviner/#diviner.load_div_lev4","title":"<code>load_div_lev4(roi, ext, savefile='T.nc', smoothday=False, invert_y=False, load_cached=True, divdir=DATA_DIR_DIVINER / 'lev4')</code>","text":"<p>Return Diviner lev4 data as xarray.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>str</code> <p>region of interest</p> required <code>ext</code> <code>list</code> <p>extent of ROI</p> required <code>savefile</code> <code>str</code> <p>Path to save result to netCDF (.nc) file</p> <code>'T.nc'</code> <code>smoothday</code> <code>bool</code> <p>smooth daytime temperatures with 2nd order polyfit</p> <code>False</code> <code>invert_y</code> <code>bool</code> <p>invert y axis (sometimes Diviner data inverted)</p> <code>False</code> <code>load_cached</code> <code>bool</code> <p>load cached data if available</p> <code>True</code> <code>divdir</code> <code>str</code> <p>path to Diviner data directory</p> <code>DATA_DIR_DIVINER / 'lev4'</code> Source code in <code>roughness/diviner.py</code> <pre><code>def load_div_lev4(\n    roi,\n    ext,\n    savefile=\"T.nc\",\n    smoothday=False,\n    invert_y=False,\n    load_cached=True,\n    divdir=DATA_DIR_DIVINER / \"lev4\",\n):\n\"\"\"\n    Return Diviner lev4 data as xarray.\n\n    Parameters:\n        roi (str): region of interest\n        ext (list): extent of ROI\n        savefile (str): Path to save result to netCDF (.nc) file\n        smoothday (bool): smooth daytime temperatures with 2nd order polyfit\n        invert_y (bool): invert y axis (sometimes Diviner data inverted)\n        load_cached (bool): load cached data if available\n        divdir (str): path to Diviner data directory\n    \"\"\"\n    roi_str = roi.replace(\"'\", \"_\").lower()\n    savepath = Path(divdir) / roi_str / savefile\n    if load_cached and savepath.exists():\n        return xr.open_dataarray(savepath)\n\n    print(\"Loading Diviner lev4 data for\", roi)\n    dirpath = Path(divdir) / roi_str\n    saveraw = None if smoothday else savepath\n    fgrds = [f.as_posix() for f in Path(dirpath).rglob(\"*.grd\")]\n    out = lev4hourly2xr(fgrds, ext, saveraw, interp_method=None)\n    if smoothday:\n        T_smooth = smooth_daytime(out, savepath)\n        out = T_smooth\n\n    # Sometimes Diviner data inverted about y - only need to fix once\n    if invert_y:\n        out = out.close()\n        tmp = xr.load_dataarray(savepath)  # load imports file and closes it\n        tmp = tmp.assign_coords(lat=tmp.lat[::-1])  # invert lat\n        tmp.to_netcdf(savepath)\n        out = xr.open_dataarray(savepath)\n    return out\n</code></pre>"},{"location":"reference/diviner/#diviner.load_div_t2r","title":"<code>load_div_t2r(fdiv_t2r=FDIV_T2R)</code>  <code>cached</code>","text":"<p>Return Diviner temperature to radiance lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>fdiv_t2r</code> <code>str</code> <p>path to Diviner t2r lookup table</p> <code>FDIV_T2R</code> Source code in <code>roughness/diviner.py</code> <pre><code>@lru_cache(1)\ndef load_div_t2r(fdiv_t2r=FDIV_T2R):\n\"\"\"\n    Return Diviner temperature to radiance lookup table.\n\n    Parameters:\n        fdiv_t2r (str): path to Diviner t2r lookup table\n    \"\"\"\n    return pd.read_csv(fdiv_t2r, index_col=0, header=0, delim_whitespace=True)\n</code></pre>"},{"location":"reference/diviner/#diviner.smooth_daytime","title":"<code>smooth_daytime(T_xarr, savefile=None)</code>","text":"<p>Return smoothed daytime T from 6 AM to 6 PM with 2nd order polyfit.</p> <p>Parameters:</p> Name Type Description Default <code>T_xarr</code> <code>DataArray</code> <p>Diviner lev4 hourly temperature data</p> required <code>savefile</code> <code>str</code> <p>Path to save result to netCDF (.nc) file</p> <code>None</code> Source code in <code>roughness/diviner.py</code> <pre><code>def smooth_daytime(T_xarr, savefile=None):\n\"\"\"\n    Return smoothed daytime T from 6 AM to 6 PM with 2nd order polyfit.\n\n    Parameters:\n        T_xarr (xr.DataArray): Diviner lev4 hourly temperature data\n        savefile (str): Path to save result to netCDF (.nc) file\n    \"\"\"\n    tres = T_xarr.tloc[1].values - T_xarr.tloc[0].values\n    Tday = T_xarr.sel(tloc=np.arange(6, 18, tres))\n    Tsmooth = xr.apply_ufunc(\n        fit_poly_daytime,\n        Tday,\n        input_core_dims=[[\"tloc\"]],\n        output_core_dims=[[\"tloc\"]],\n        vectorize=True,\n    )\n    if savefile:\n        Tsmooth.to_netcdf(savefile)\n    return Tsmooth\n</code></pre>"},{"location":"reference/emission/","title":"emission","text":"<p>Compute rough emission curves.</p>"},{"location":"reference/emission/#emission.bb_emission_eq","title":"<code>bb_emission_eq(sun_theta, wls, albedo, emiss, solar_dist)</code>","text":"<p>Return isothermal blackbody emission spectrum assuming radiative equilibrium.</p> <p>Parameters:</p> Name Type Description Default <code>sun_theta</code> <code>float</code> <p>Solar incidence angle [deg].</p> required <code>wls</code> <code>ndarray</code> <p>Wavelengths [microns].</p> required <code>albedo</code> <code>float</code> <p>Hemispherical broadband albedo.</p> required <code>emiss</code> <code>float</code> <p>Emissivity.</p> required <code>solar_dist</code> <code>float</code> <p>Solar distance (au).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Blackbody emission spectrum vs. wls [W m^-2].</p> Source code in <code>roughness/emission.py</code> <pre><code>def bb_emission_eq(sun_theta, wls, albedo, emiss, solar_dist):\n\"\"\"\n    Return isothermal blackbody emission spectrum assuming radiative\n    equilibrium.\n\n    Parameters:\n        sun_theta (float): Solar incidence angle [deg].\n        wls (ndarray): Wavelengths [microns].\n        albedo (float): Hemispherical broadband albedo.\n        emiss (float): Emissivity.\n        solar_dist (float): Solar distance (au).\n\n    Returns:\n        (np.ndarray): Blackbody emission spectrum vs. wls [W m^-2].\n    \"\"\"\n    cinc = np.cos(np.deg2rad(sun_theta))\n    albedo_array = get_albedo_scaling(sun_theta, albedo)\n    rad_isot = get_emission_eq(cinc, albedo_array, emiss, solar_dist)\n    temp_isot = get_temp_sb(rad_isot)\n    bb_emission = cmrad2mrad(bbrw(wls, temp_isot))\n    return bb_emission\n</code></pre>"},{"location":"reference/emission/#emission.bbr","title":"<code>bbr(wavenumber, temp, radunits='wn')</code>","text":"<p>Return blackbody radiance at given wavenumber(s) and temp(s).</p> <p>Units='wn' for wavenumber: W/(m^2 sr cm^-1)       'wl' for wavelength: W/(m^2 sr \u03bcm)</p> <p>Translated from ff_bbr.c in davinci_2.22.</p> <p>Parameters:</p> Name Type Description Default <code>wavenumber</code> <code>num | arr</code> <p>Wavenumber(s) to compute radiance at [cm^-1]</p> required <code>temp</code> <code>num | arr</code> <p>Temperatue(s) to compute radiance at [K]</p> required <code>radunits</code> <code>str</code> <p>Return units in terms of wn or wl (wn: cm^-1; wl: \u03bcm)</p> <code>'wn'</code> Source code in <code>roughness/emission.py</code> <pre><code>def bbr(wavenumber, temp, radunits=\"wn\"):\n\"\"\"\n    Return blackbody radiance at given wavenumber(s) and temp(s).\n\n    Units='wn' for wavenumber: W/(m^2 sr cm^-1)\n          'wl' for wavelength: W/(m^2 sr \u03bcm)\n\n    Translated from ff_bbr.c in davinci_2.22.\n\n    Parameters:\n        wavenumber (num | arr): Wavenumber(s) to compute radiance at [cm^-1]\n        temp (num | arr): Temperatue(s) to compute radiance at [K]\n        radunits (str): Return units in terms of wn or wl (wn: cm^-1; wl: \u03bcm)\n    \"\"\"\n    # Derive Planck radiation constants a and b from h, c, Kb\n    a = 2 * HC * CCM**2  # [J cm^2 / s] = [W cm^2]\n    b = HC * CCM / KB  # [cm K]\n\n    if np.isscalar(temp):\n        if temp &lt;= 0:\n            temp = 1\n    elif isinstance(temp, xr.DataArray):\n        temp = temp.clip(min=1)\n    else:\n        temp[temp &lt; 0] = 1\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        rad = (a * wavenumber**3) / (np.exp(b * wavenumber / temp) - 1.0)\n    if radunits == \"wl\":\n        rad = wnrad2wlrad(wavenumber, rad)  # [W/(cm^2 sr \u03bcm)]\n    return rad\n</code></pre>"},{"location":"reference/emission/#emission.bbrw","title":"<code>bbrw(wavelength, temp, radunits='wl')</code>","text":"<p>Return blackbody radiance at given wavelength(s) and temp(s).</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>num | arr</code> <p>Wavelength(s) to compute radiance at [microns]</p> required <code>temp</code> <code>num | arr</code> <p>Temperatue(s) to compute radiance at [K]</p> required Source code in <code>roughness/emission.py</code> <pre><code>def bbrw(wavelength, temp, radunits=\"wl\"):\n\"\"\"\n    Return blackbody radiance at given wavelength(s) and temp(s).\n\n    Parameters:\n        wavelength (num | arr): Wavelength(s) to compute radiance at [microns]\n        temp (num | arr): Temperatue(s) to compute radiance at [K]\n    \"\"\"\n    return bbr(wl2wn(wavelength), temp, radunits)\n</code></pre>"},{"location":"reference/emission/#emission.btemp","title":"<code>btemp(wavenumber, radiance, radunits='wn')</code>","text":"<p>Return brightness temperature [K] from wavenumber and radiance.</p> <p>Translated from ff_bbr.c in davinci_2.22.</p> Source code in <code>roughness/emission.py</code> <pre><code>def btemp(wavenumber, radiance, radunits=\"wn\"):\n\"\"\"\n    Return brightness temperature [K] from wavenumber and radiance.\n\n    Translated from ff_bbr.c in davinci_2.22.\n    \"\"\"\n    # Derive Planck radiation constants a and b from h, c, Kb\n    a = 2 * HC * CCM**2  # [J cm^2 / s] = [W cm^2]\n    b = HC * CCM / KB  # [cm K]\n    if radunits == \"wl\":\n        # [W/(cm^2 sr \u03bcm)] -&gt; [W/(cm^2 sr cm^-1)]\n        radiance = wlrad2wnrad(wn2wl(wavenumber), radiance)\n    T = (b * wavenumber) / np.log(1.0 + (a * wavenumber**3 / radiance))\n    return T\n</code></pre>"},{"location":"reference/emission/#emission.btempw","title":"<code>btempw(wavelength, radiance, radunits='wl')</code>","text":"<p>Return brightness temperature [K] at wavelength given radiance.</p> Source code in <code>roughness/emission.py</code> <pre><code>def btempw(wavelength, radiance, radunits=\"wl\"):\n\"\"\"\n    Return brightness temperature [K] at wavelength given radiance.\n\n    \"\"\"\n    return btemp(wl2wn(wavelength), radiance, radunits=radunits)\n</code></pre>"},{"location":"reference/emission/#emission.cmrad2mrad","title":"<code>cmrad2mrad(cmrad)</code>","text":"<p>Convert radiance from units W/(cm^2 sr \u03bcm) to W/(m^2 sr \u03bcm).</p> Source code in <code>roughness/emission.py</code> <pre><code>def cmrad2mrad(cmrad):\n\"\"\"Convert radiance from units W/(cm^2 sr \u03bcm) to W/(m^2 sr \u03bcm).\"\"\"\n    return cmrad * 1e4  # [W/(cm^2 sr \u03bcm)] -&gt; [W/(m^2 sr \u03bcm)]\n</code></pre>"},{"location":"reference/emission/#emission.cos_facet_sun_inc","title":"<code>cos_facet_sun_inc(surf_theta, surf_az, sun_theta, sun_az)</code>","text":"<p>Return cos solar incidence of surface slopes (surf_theta, surf_az) given sun location (sun_theta, sun_az) using the dot product.</p> <p>If cinc &lt; 0, angle b/t surf and sun is &gt; 90 degrees. Limit these values to cinc = 0.</p> <p>Parameters:</p> Name Type Description Default <code>surf_theta</code> <code>float | ndarray</code> <p>Surface slope(s) in degrees.</p> required <code>surf_az</code> <code>float | ndarray</code> <p>Surface azimuth(s) in degrees.</p> required <code>sun_theta</code> <code>float</code> <p>Solar incidence angle in degrees.</p> required <code>sun_az</code> <code>float</code> <p>Solar azimuth from North in degrees.</p> required Source code in <code>roughness/emission.py</code> <pre><code>def cos_facet_sun_inc(surf_theta, surf_az, sun_theta, sun_az):\n\"\"\"\n    Return cos solar incidence of surface slopes (surf_theta, surf_az) given\n    sun location (sun_theta, sun_az) using the dot product.\n\n    If cinc &lt; 0, angle b/t surf and sun is &gt; 90 degrees. Limit these values to\n    cinc = 0.\n\n    Parameters:\n        surf_theta (float | np.ndarray): Surface slope(s) in degrees.\n        surf_az (float | np.ndarray): Surface azimuth(s) in degrees.\n        sun_theta (float): Solar incidence angle in degrees.\n        sun_az (float): Solar azimuth from North in degrees.\n    \"\"\"\n    facet_vec = rh.sph2cart(np.deg2rad(surf_theta), np.deg2rad(surf_az))\n    target_vec = rh.sph2cart(np.deg2rad(sun_theta), np.deg2rad(sun_az))\n    cinc = (facet_vec * target_vec).sum(axis=2)\n    cinc[cinc &lt; 0] = 0\n    if isinstance(surf_theta, xr.DataArray):\n        cinc = xr.ones_like(surf_theta) * cinc\n        cinc.name = \"cos(inc)\"\n    return cinc\n</code></pre>"},{"location":"reference/emission/#emission.directional_emiss","title":"<code>directional_emiss(theta)</code>","text":"<p>Return directional emissivity at angle theta.</p> Source code in <code>roughness/emission.py</code> <pre><code>def directional_emiss(theta):\n\"\"\"\n    Return directional emissivity at angle theta.\n    \"\"\"\n    thetar = np.deg2rad(theta)\n    # emiss = 0.993 - 0.0302 * thetar - 0.0897 * thetar**2\n    # Powell 2023 (mean goes down to ~0.8)\n    emiss = np.cos(thetar) ** 0.151\n    return np.clip(emiss, 0.8, 1)\n</code></pre>"},{"location":"reference/emission/#emission.emission_2component","title":"<code>emission_2component(wavelength, temp_illum, temp_shadow, shadow_table, emissivity=1)</code>","text":"<p>Return roughness emission spectrum at given wls given the temperature of illuminated and shadowed surfaces and fraction of the surface in shadow.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>num | arr</code> <p>Wavelength(s) [microns]</p> required <code>temp_illum</code> <code>num | arr</code> <p>Temperature(s) of illuminated fraction of surface</p> required <code>temp_shadow</code> <code>num | arr</code> <p>Temperature(s) of shadowed fraction of surface</p> required <code>shadow_table</code> <code>num | arr</code> <p>Proportion(s) of surface in shadow</p> required Source code in <code>roughness/emission.py</code> <pre><code>def emission_2component(\n    wavelength,\n    temp_illum,\n    temp_shadow,\n    shadow_table,\n    emissivity=1,\n):\n\"\"\"\n    Return roughness emission spectrum at given wls given the temperature\n    of illuminated and shadowed surfaces and fraction of the surface in shadow.\n\n    Parameters:\n        wavelength (num | arr): Wavelength(s) [microns]\n        temp_illum (num | arr): Temperature(s) of illuminated fraction of\n            surface\n        temp_shadow (num | arr): Temperature(s) of shadowed fraction of\n            surface\n        shadow_table (num | arr): Proportion(s) of surface in shadow\n    \"\"\"\n    rad_illum = temp2rad(wavelength, temp_illum, emissivity)\n    rad_shade = temp2rad(wavelength, temp_shadow, emissivity)\n    rad_total = rad_illum * (1 - shadow_table) + rad_shade * shadow_table\n    return rad_total\n</code></pre>"},{"location":"reference/emission/#emission.emission_spectrum","title":"<code>emission_spectrum(emission_table, weight_table=None)</code>","text":"<p>Return emission spectrum as weighted sum of facets in emission_table.</p> <p>Weight_table must have same slope, az coords as emission_table.</p> <p>Parameters:</p> Name Type Description Default <code>emission_table</code> <code>DataArray</code> <p>Table of radiance at each facet.</p> required <code>weight_table</code> <code>DataArray</code> <p>Table of facet weights.</p> <code>None</code> Source code in <code>roughness/emission.py</code> <pre><code>def emission_spectrum(emission_table, weight_table=None):\n\"\"\"\n    Return emission spectrum as weighted sum of facets in emission_table.\n\n    Weight_table must have same slope, az coords as emission_table.\n\n    Parameters:\n        emission_table (xr.DataArray): Table of radiance at each facet.\n        weight_table (xr.DataArray): Table of facet weights.\n    \"\"\"\n    if weight_table is None and isinstance(emission_table, xr.DataArray):\n        weight_table = 1 / (len(emission_table.az) * len(emission_table.theta))\n    elif weight_table is None:\n        weight_table = 1 / np.prod(emission_table.shape[:2])\n\n    if isinstance(emission_table, xr.DataArray):\n        weighted = emission_table.weighted(weight_table.fillna(0))\n        spectrum = weighted.sum(dim=(\"az\", \"theta\"))\n        spectrum.name = \"Radiance [W/m\u00b2/sr/\u03bcm]\"\n    else:\n        weighted = emission_table * weight_table\n        spectrum = np.sum(weighted, axis=(0, 1))\n    return spectrum\n</code></pre>"},{"location":"reference/emission/#emission.get_albedo_scaling","title":"<code>get_albedo_scaling(inc, albedo=0.12, a=None, b=None, mode='vasavada')</code>","text":"<p>Return albedo scaled with solar incidence angle (eq A5; Keihm, 1984).</p> <p>Parameters a and b have been measured since Keihm (1984) and may differ for non-lunar bodies. Optionally supply a and b or select a mode:     modes:         'king': Use lunar a, b from King et al. (2020)         'hayne': Use lunar a, b from Hayne et al. (2017)         'vasavada': Use lunar a, b from Vasavada et al. (2012)         else: Use original a, b from Keihm (1984) Note: if a or b is supplied, both must be supplied and supercede mode</p> <p>Parameters:</p> Name Type Description Default <code>albedo</code> <code>num</code> <p>Lunar average bond albedo (at inc=0).</p> <code>0.12</code> <code>inc</code> <code>num | arr</code> <p>Solar incidence angle [deg].</p> required <code>mode</code> <code>str</code> <p>Scale albedo based on published values of a, b.</p> <code>'vasavada'</code> Source code in <code>roughness/emission.py</code> <pre><code>def get_albedo_scaling(inc, albedo=0.12, a=None, b=None, mode=\"vasavada\"):\n\"\"\"\n    Return albedo scaled with solar incidence angle (eq A5; Keihm, 1984).\n\n    Parameters a and b have been measured since Keihm (1984) and may differ for\n    non-lunar bodies. Optionally supply a and b or select a mode:\n        modes:\n            'king': Use lunar a, b from King et al. (2020)\n            'hayne': Use lunar a, b from Hayne et al. (2017)\n            'vasavada': Use lunar a, b from Vasavada et al. (2012)\n            else: Use original a, b from Keihm (1984)\n    Note: if a or b is supplied, both must be supplied and supercede mode\n\n    Parameters:\n        albedo (num): Lunar average bond albedo (at inc=0).\n        inc (num | arr): Solar incidence angle [deg].\n        mode (str): Scale albedo based on published values of a, b.\n    \"\"\"\n    if a is not None and b is not None:\n        pass\n    elif mode == \"king\":\n        # King et al. (2020)\n        a = 0.0165\n        b = -0.03625\n    elif mode == \"hayne\":\n        # Hayne et al. (2017)\n        a = 0.06\n        b = 0.25\n    elif mode == \"vasavada\":\n        # Vasavada et al. (2012)\n        a = 0.045\n        b = 0.14\n    else:\n        # Keihm et al. (1984)\n        a = 0.03\n        b = 0.14\n    alb_scaled = albedo + a * (inc / 45) ** 3 + b * (inc / 90) ** 8\n    return alb_scaled\n</code></pre>"},{"location":"reference/emission/#emission.get_emission_eq","title":"<code>get_emission_eq(cinc, albedo, emissivity, solar_dist)</code>","text":"<p>Return radiated emission assuming radiative equillibrium.</p> <p>Parameters:</p> Name Type Description Default <code>cinc</code> <code>num</code> <p>Cosine of solar incidence.</p> required <code>albedo</code> <code>num</code> <p>Hemispherical broadband albedo.</p> required <code>emissivity</code> <code>num</code> <p>Hemispherical broadband emissivity.</p> required <code>solar_dist</code> <code>num</code> <p>Solar distance (au).</p> required Source code in <code>roughness/emission.py</code> <pre><code>def get_emission_eq(cinc, albedo, emissivity, solar_dist):\n\"\"\"\n    Return radiated emission assuming radiative equillibrium.\n\n    Parameters:\n        cinc (num): Cosine of solar incidence.\n        albedo (num): Hemispherical broadband albedo.\n        emissivity (num): Hemispherical broadband emissivity.\n        solar_dist (num): Solar distance (au).\n    \"\"\"\n    f_sun = SC / solar_dist**2\n    rad_eq = f_sun * cinc * (1 - albedo) / emissivity\n    if isinstance(cinc, xr.DataArray):\n        rad_eq.name = \"Radiance [W/m\u00b2]\"\n    return rad_eq\n</code></pre>"},{"location":"reference/emission/#emission.get_emissivity_table","title":"<code>get_emissivity_table(facet_theta, facet_az, sc_theta, sc_az)</code>","text":"<p>Return emissivity table for given shadow_table and solar incidence angle.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_emissivity_table(facet_theta, facet_az, sc_theta, sc_az):\n\"\"\"\n    Return emissivity table for given shadow_table and solar incidence angle.\n\n    \"\"\"\n    cinc = rn.get_facet_cos_theta(facet_theta, facet_az, sc_theta, sc_az)\n    # Bandfield et al. (2015) nighttime fit\n    emissivity = 0.99 * cinc**0.14\n    return emissivity\n</code></pre>"},{"location":"reference/emission/#emission.get_facet_temp_illum_eq","title":"<code>get_facet_temp_illum_eq(shadow_table, sun_theta, sun_az, albedo, emiss, solar_dist, rerad=True)</code>","text":"<p>Return temperature of illuminated facets assuming radiative equilibrium. Uses shadow_table generated by get_shadow_table.</p> <p>Parameters:</p> Name Type Description Default <code>shadow_table</code> <code>ndarray</code> <p>Shadow table.</p> required <code>sun_theta</code> <code>float</code> <p>Solar incidence angle.</p> required <code>sun_az</code> <code>float</code> <p>Solar azimuth.</p> required <code>albedo</code> <code>float</code> <p>Hemispherical broadband albedo.</p> required <code>emiss</code> <code>float</code> <p>Emissivity.</p> required <code>solar_dist</code> <code>float</code> <p>Solar distance (au).</p> required <code>rerad</code> <code>bool</code> <p>If True, include re-radiation from adjacent facets. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Facet temperatures.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_facet_temp_illum_eq(\n    shadow_table, sun_theta, sun_az, albedo, emiss, solar_dist, rerad=True\n):\n\"\"\"\n    Return temperature of illuminated facets assuming radiative\n    equilibrium. Uses shadow_table generated by get_shadow_table.\n\n    Parameters:\n        shadow_table (ndarray): Shadow table.\n        sun_theta (float): Solar incidence angle.\n        sun_az (float): Solar azimuth.\n        albedo (float): Hemispherical broadband albedo.\n        emiss (float): Emissivity.\n        solar_dist (float): Solar distance (au).\n        rerad (bool, optional): If True, include re-radiation from adjacent\n            facets. Default is True.\n\n    Returns:\n        (np.ndarray): Facet temperatures.\n    \"\"\"\n    # Produce sloped facets at same resolution as shadow_table\n    f_theta, f_az = rh.facet_grids(shadow_table)\n    cinc = rn.get_facet_cos_theta(f_theta, f_az, sun_theta, sun_az)\n    # cinc = cos_facet_sun_inc(f_theta, f_az, sun_theta, sun_az)\n    facet_inc = np.degrees(np.arccos(cinc))\n    albedo_array = get_albedo_scaling(facet_inc, albedo)\n    # Compute total radiance of sunlit facets assuming radiative eq\n    rad_illum = get_emission_eq(cinc, albedo_array, emiss, solar_dist)\n    if rerad:\n        rad0 = rad_illum[0, 0]  # Radiance of level surface facet\n        alb0 = albedo_array[0, 0]  # Albedo of level surface facet\n        rad_illum += get_reradiation(\n            cinc, f_theta, albedo, emiss, solar_dist, rad0, alb0\n        )\n\n    # Convert to temperature with Stefan-Boltzmann law\n    facet_temp_illum = get_temp_sb(rad_illum)\n    return facet_temp_illum\n</code></pre>"},{"location":"reference/emission/#emission.get_rad_factor","title":"<code>get_rad_factor(rad, solar_irr, emission=None, emissivity=None)</code>","text":"<p>Return radiance factor (I/F) given observed radiance, modeled emission, solar irradiance and emissivity. If no emissivity is supplied, assume Kirchoff's Law (eq. 6, Bandfield et al., 2018).</p> <p>Parameters:</p> Name Type Description Default <code>rad</code> <code>num | arr</code> <p>Observed radiance [W m^-2 \u03bcm^-1]</p> required <code>emission</code> <code>num | arr</code> <p>Emission to remove from rad [W m^-2 \u03bcm^-1]</p> <code>None</code> <code>solar_irr</code> <code>num | arr</code> <p>Solar irradiance [W m^-2 \u03bcm^-1]</p> required <code>emissivity</code> <code>num | arr</code> <p>Emissivity (if None, assume Kirchoff)</p> <code>None</code> Source code in <code>roughness/emission.py</code> <pre><code>def get_rad_factor(rad, solar_irr, emission=None, emissivity=None):\n\"\"\"\n    Return radiance factor (I/F) given observed radiance, modeled emission,\n    solar irradiance and emissivity. If no emissivity is supplied,\n    assume Kirchoff's Law (eq. 6, Bandfield et al., 2018).\n\n    Parameters:\n        rad (num | arr): Observed radiance [W m^-2 \u03bcm^-1]\n        emission (num | arr): Emission to remove from rad [W m^-2 \u03bcm^-1]\n        solar_irr (num | arr): Solar irradiance [W m^-2 \u03bcm^-1]\n        emissivity (num | arr): Emissivity (if None, assume Kirchoff)\n    \"\"\"\n    emissivity = 1 if emissivity is None else emissivity\n    if emission is not None and emissivity is None:\n        # Assume Kirchoff's Law to compute emissivity\n        emissivity = (rad - solar_irr) / (emission - solar_irr)\n    return (rad - emissivity * emission) / solar_irr\n</code></pre>"},{"location":"reference/emission/#emission.get_rad_sb","title":"<code>get_rad_sb(temp)</code>","text":"<p>Return radiance assuming the Stefan-Boltzmann Law given temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temp</code> <code>num | arr</code> <p>Temperature [K]</p> required Source code in <code>roughness/emission.py</code> <pre><code>def get_rad_sb(temp):\n\"\"\"\n    Return radiance assuming the Stefan-Boltzmann Law given temperature.\n\n    Parameters:\n        temp (num | arr): Temperature [K]\n    \"\"\"\n    rad = SB * temp**4\n    if isinstance(temp, xr.DataArray):\n        rad.name = \"Radiance [W m^-2]\"\n    return rad\n</code></pre>"},{"location":"reference/emission/#emission.get_reradiation","title":"<code>get_reradiation(cinc, surf_theta, albedo, emissivity, solar_dist, rad0, alb0=0.12)</code>","text":"<p>Return emission incident on surf_theta from re-radiating adjacent level surfaces. Approximation from JB modified from downwelling radiance.</p> <p>Parameters:</p> Name Type Description Default <code>cinc</code> <code>num | arr</code> <p>Cosine of solar incidence.</p> required <code>surf_theta</code> <code>num | arr</code> <p>Surface slope(s) in degrees.</p> required <code>albedo</code> <code>num | arr</code> <p>Albedo (hemispherical if num, scaled by cinc if array).</p> required <code>emissivity</code> <code>num</code> <p>Hemispherical broadband emissivity.</p> required <code>solar_dist</code> <code>num</code> <p>Solar distance (au).</p> required <code>rad0</code> <code>num</code> <p>Radiance of level surface facet.</p> required <code>alb0</code> <code>num</code> <p>Albedo of level surface facet.</p> <code>0.12</code> Source code in <code>roughness/emission.py</code> <pre><code>def get_reradiation(\n    cinc, surf_theta, albedo, emissivity, solar_dist, rad0, alb0=0.12\n):\n\"\"\"\n    Return emission incident on surf_theta from re-radiating adjacent level\n    surfaces. Approximation from JB modified from downwelling radiance.\n\n    Parameters:\n        cinc (num | arr): Cosine of solar incidence.\n        surf_theta (num | arr): Surface slope(s) in degrees.\n        albedo (num | arr): Albedo (hemispherical if num, scaled by cinc if array).\n        emissivity (num): Hemispherical broadband emissivity.\n        solar_dist (num): Solar distance (au).\n        rad0 (num): Radiance of level surface facet.\n        alb0 (num): Albedo of level surface facet.\n    \"\"\"\n    # Albedo scaled by angle b/t facet and level surface (e.g. surf_theta)\n    # TODO: Why scale by alb_level / 0.12?\n    level_albedo = get_albedo_scaling(surf_theta, albedo) * alb0 / 0.12\n    level_rad = get_emission_eq(cinc, level_albedo, emissivity, solar_dist)\n\n    # Assuming infinite level plane visible from facet slope, the factor\n    #  surf_theta / 180 gives incident reradiation\n    rerad = (surf_theta / 180) * emissivity * (rad0 + alb0 * level_rad)\n\n    if isinstance(rerad, xr.DataArray):\n        rerad = rerad.clip(min=0)\n    else:\n        rerad[rerad &lt; 0] = 0\n    return rerad\n</code></pre>"},{"location":"reference/emission/#emission.get_reradiation_alt","title":"<code>get_reradiation_alt(rad_table, sun_theta, sun_az, tflat, tvert, albedo=0.12, emiss=0.95)</code>","text":"<p>Return emission incident on surf_theta from re-radiating adjacent level surfaces using lookup table. Modified from JB downwelling approximation.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_reradiation_alt(\n    rad_table, sun_theta, sun_az, tflat, tvert, albedo=0.12, emiss=0.95\n):\n\"\"\"\n    Return emission incident on surf_theta from re-radiating adjacent level\n    surfaces using lookup table. Modified from JB downwelling approximation.\n\n    \"\"\"\n    # cinc = rn.get_facet_cos_theta(facet_theta, facet_az, sun_theta, sun_az)\n\n    # Reflected radiance from sun to facet to each other facet?\n    # (solar rad * facet albedo)/pi * cos(inc to each facet)\n\n    # Emission from each facet to each other facet assuming lambertian\n    # (sigT^4 * facet emissivity)/pi * cos(inc to each facet) * (1-albedo)\n    # should be weighted by P(facet) - what is it scaled to? if we weight,\n    #  we're presuming a total amount of rerad right?\n    # rerad_table = get_rad_sb(temp_table) * emissivity / np.pi\n    # rerad_table = rn.rotate_az_lookup(rerad_table, target_az=180, az0=0)\n\n    # rerad_table *= (rerad_table.theta / 180) * albedo\n\n    # # Get scattered solar rad from level surface to each facet\n    # albedo_eff = get_albedo_scaling(sun_theta, albedo)\n    # rad_eq_sun = get_rad_sb(t_flat) * emiss / (1 - albedo_eff)\n    # rerad_scattered = rad_eq_sun * albedo_eff\n\n    # # Get reradiated emission from level suface to each facet\n    # # frac is integrated solid angle in each theta, az bin\n    # naz = len(rad_table.az)  # Assume az symmetric\n    # facet_theta = rad_table.theta\n    # dtheta = (facet_theta[1] - facet_theta[0]) / 2\n    # theta_bins = np.append(facet_theta - dtheta, facet_theta[-1] + dtheta)\n    # thetar = np.deg2rad(theta_bins)\n    # theta_frac = np.cos(thetar[:-1]) - np.cos(thetar[1:])\n    # frac = theta_frac / naz\n\n    # # emiss = directional_emiss(90 - facet_theta)\n    # rerad_emitted = get_rad_sb(t_flat) * emiss\n\n    # # Final radiance scattered and emitted from flat surface\n    # # rerad = frac * rerad_emitted + frac * rerad_scattered\n    # rerad = (rerad_emitted + rerad_scattered)\n\n    albedo_eff = get_albedo_scaling(sun_theta, albedo)\n    rad_eq_sun = get_rad_sb(tflat) * emiss / (1 - albedo_eff)\n    rerad_scattered = rad_eq_sun * albedo_eff\n    rerad_emitted = get_rad_sb(tflat) * emiss\n    # print(rerad_emitted, rerad_scattered)\n    # Adjacent facet approx 1 - cos(facet_theta)\n    naz = len(rad_table.az)  # Assume az symmetric\n    facet_theta = rad_table.theta\n    dtheta = (facet_theta[1] - facet_theta[0]) / 2\n    theta_bins = np.append(facet_theta - dtheta, facet_theta[-1] + dtheta)\n    thetar = np.deg2rad(theta_bins)\n    theta_frac = np.cos(thetar[:-1]) - np.cos(thetar[1:])\n    fflat = theta_frac / naz\n\n    # Final radiance scattered and emitted from flat surface\n    albflat = get_albedo_scaling(facet_theta, albedo=albedo)\n    rerad_flat = fflat * (rerad_emitted + rerad_scattered * (1 - albflat))\n\n    # Rerad vert\n    albedo_eff = get_albedo_scaling(90 - sun_theta, albedo)\n    rad_eq_sun = get_rad_sb(tvert) * emiss / (1 - albedo_eff)\n    rerad_scattered = rad_eq_sun * albedo_eff\n    rerad_emitted = get_rad_sb(tvert) * emiss\n    # print(rerad_emitted, rerad_scattered)\n    # # Adjacent facet approx 1 - sin(facet_theta)\n    # naz = len(table.az)  # Assume az symmetric\n    # facet_theta = table.theta\n    # theta_frac = 1 - np.sin(np.deg2rad(facet_theta))\n    # frac = theta_frac / naz\n\n    dtheta = (rad_table.theta[1] - rad_table.theta[0]) / 2\n    theta_bins = np.append(\n        rad_table.theta - dtheta, rad_table.theta[-1] + dtheta\n    )\n    daz = (rad_table.az[1] - rad_table.az[0]) / 2\n    az_bins = np.append(rad_table.az - daz, rad_table.az[-1] + daz)\n    # theta, az = np.meshgrid(theta_bins, az_bins)\n    thetar = np.deg2rad(theta_bins)\n    azr = np.deg2rad(az_bins - sun_az)\n    ftheta = np.sin(thetar[1:]) - np.sin(thetar[:-1])\n    faz = np.abs(np.cos(azr[1:] / 2) - np.cos(azr[:-1] / 2))\n    faz = faz / faz.sum()\n    fvert = faz[:, np.newaxis] * ftheta\n\n    # Final radiance scattered and emitted from vert surface\n    #  todo: 1/2 vert because half is scattered to space\n    albvert = get_albedo_scaling(90 - facet_theta, albedo=albedo)\n    rerad_vert = fvert * (\n        rerad_emitted + rerad_scattered * (1 - albvert.values)\n    )\n    rerad_tot = 4 * np.pi * (rerad_flat.values + rerad_vert)\n\n    # rerad is too low when we integrate over facets. probably because we're\n    #  only accounting for one flat and one vert surface. seemed to be a bit\n    #  better when we didn't integrate fflat and fvert = 1, but instead used\n    #  something like 1 - cos(facet_theta) and 1 - sin(facet_theta)\n    return rerad_tot\n</code></pre>"},{"location":"reference/emission/#emission.get_reradiation_jb","title":"<code>get_reradiation_jb(sun_theta, facet_theta, t_flat, albedo=0.12, emiss=0.95, alb_scaling='vasavada', solar_dist=1)</code>","text":"<p>Return emission incident on surf_theta from re-radiating adjacent level surfaces using JB downwelling approximation.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_reradiation_jb(\n    sun_theta,\n    facet_theta,\n    t_flat,\n    albedo=0.12,\n    emiss=0.95,\n    alb_scaling=\"vasavada\",\n    solar_dist=1,\n):\n\"\"\"\n    Return emission incident on surf_theta from re-radiating adjacent level\n    surfaces using JB downwelling approximation.\n    \"\"\"\n    # emiss = 0.77\n    facet_alb = get_albedo_scaling(\n        facet_theta, albedo=albedo, mode=alb_scaling\n    )\n    rerad_emitted = get_rad_sb(t_flat) * emiss\n    rerad_reflected = (\n        SC\n        / solar_dist**2\n        * np.cos(np.deg2rad(sun_theta))\n        * get_albedo_scaling(sun_theta, albedo, mode=alb_scaling)\n    )\n    rerad_absorbed = (facet_theta / 180) * (\n        rerad_emitted + (1 - facet_alb) * rerad_reflected\n    )\n    return rerad_absorbed\n</code></pre>"},{"location":"reference/emission/#emission.get_reradiation_new","title":"<code>get_reradiation_new(tflat, albedo=0.12, emiss=0.95)</code>","text":"<p>Compute upwelling reradiation from flat surface.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_reradiation_new(tflat, albedo=0.12, emiss=0.95):\n\"\"\"Compute upwelling reradiation from flat surface.\"\"\"\n    q_emis = get_rad_sb(tflat) * emiss\n    q_sun = q_emis / (1 - albedo)\n    q_scattered = q_sun * albedo\n    q_rerad = (1 - albedo) * (q_emis + q_scattered)\n    return q_rerad\n</code></pre>"},{"location":"reference/emission/#emission.get_shadow_temp","title":"<code>get_shadow_temp(sun_theta, sun_az, temp0)</code>","text":"<p>Return temperature of shadows. Nominally 100 K less than the rad_eq surf_temp. At high solar incidence, scale shadow temperature by inc angle. Evening shadows are warmer than morning shadows. Tuned for lunar eqautor by Bandfield et al. (2015, 2018).</p> <p>Parameters:</p> Name Type Description Default <code>sun_theta</code> <code>num</code> <p>Solar incidence angle [deg]</p> required <code>sun_az</code> <code>num</code> <p>Solar azimuth from N [deg]</p> required <code>temp0</code> <code>num</code> <p>Temperature of illuminated level surface facet [K]</p> required Source code in <code>roughness/emission.py</code> <pre><code>def get_shadow_temp(sun_theta, sun_az, temp0):\n\"\"\"\n    Return temperature of shadows. Nominally 100 K less than the rad_eq\n    surf_temp. At high solar incidence, scale shadow temperature by inc angle.\n    Evening shadows are warmer than morning shadows. Tuned for lunar eqautor\n    by Bandfield et al. (2015, 2018).\n\n    Parameters:\n        sun_theta (num): Solar incidence angle [deg]\n        sun_az (num): Solar azimuth from N [deg]\n        temp0 (num): Temperature of illuminated level surface facet [K]\n    \"\"\"\n    shadow_temp_factor = 1\n    if sun_theta &gt;= 60 and 0 &lt;= sun_az &lt; 180:\n        shadow_temp_factor = 1 - 0.6 * (sun_theta % 60) / 30\n    elif sun_theta &gt;= 60 and 180 &lt;= sun_az &lt; 360:\n        shadow_temp_factor = 1 - 0.75 * (sun_theta % 60) / 30\n    shadow_temp = temp0 - 100 * shadow_temp_factor\n    return shadow_temp\n</code></pre>"},{"location":"reference/emission/#emission.get_shadow_temp_new","title":"<code>get_shadow_temp_new(temp_table, tparams, cst=0.5, tlookup=TLOOKUP)</code>","text":"<p>Return cast shadow temperature using current and dawn (coldest) temperatures and the cast shadow time, cst.</p> <p>Parameters:</p> Name Type Description Default <code>temp_table</code> <code>ndarray</code> <p>Temperature table.</p> required <code>tparams</code> <code>dict</code> <p>Dictionary of temperature lookup parameters.</p> required <code>cst</code> <code>float</code> <p>Fraction of time since dawn. Default is 0.5.</p> <code>0.5</code> <code>tlookup</code> <code>path</code> <p>Temperature lookup xarray or path to file. Default is TLOOKUP.</p> <code>TLOOKUP</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Cast shadow temperature table.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_shadow_temp_new(temp_table, tparams, cst=0.5, tlookup=TLOOKUP):\n\"\"\"\n    Return cast shadow temperature using current and dawn (coldest)\n    temperatures and the cast shadow time, cst.\n\n    Parameters:\n        temp_table (ndarray): Temperature table.\n        tparams (dict): Dictionary of temperature lookup parameters.\n        cst (float, optional): Fraction of time since dawn. Default is 0.5.\n        tlookup (path, optional): Temperature lookup xarray or path\n            to file. Default is TLOOKUP.\n\n    Returns:\n        (np.ndarray): Cast shadow temperature table.\n    \"\"\"\n    # Shadow age is cst fraction * time since dawn\n    shadow_age = (tparams[\"tloc\"] - 6) * cst\n\n    # Tloc of last illumination is tloc - shadow_age\n    last_illum = tparams[\"tloc\"] - shadow_age\n\n    # Twarm is when surfaces were last illuminated\n    twparams = tparams.copy()\n    twparams[\"tloc\"] = last_illum\n    twarm = get_temp_table(twparams, tlookup)\n\n    # Tcold is dawn temp\n    tcparams = tparams.copy()\n    tcparams[\"tloc\"] = 6\n    tcold = get_temp_table(tcparams, tlookup)\n\n    # Linearly scale shadow temp between last illuminated temp and dawn temp\n    tshadow = cst * tcold + (1 - cst) * twarm\n    return tshadow.interp_like(temp_table)\n</code></pre>"},{"location":"reference/emission/#emission.get_shadow_temp_table","title":"<code>get_shadow_temp_table(temp_table, sun_theta, sun_az, tparams, cst, tlookup=TLOOKUP)</code>","text":"<p>Return shadow temperature for each facet in temp_illum.</p> <p>Facets where solar incidence angle &gt; 90 degrees (shaded relief) retain the temp_table value since the sun has simply set in thermal model.</p> <p>Facets where solar incidence angle &lt; 90 degrees (cast shadow) are set to a shadow temperature following Bandfield et al. (2018).</p> <p>Parameters:</p> Name Type Description Default <code>temp_table</code> <code>DataArray</code> <p>Table of facet temperatures.</p> required <code>sun_theta</code> <code>float</code> <p>Solar incidence angle.</p> required <code>sun_az</code> <code>float</code> <p>Solar azimuth.</p> required <code>tparams</code> <code>dict</code> <p>Dictionary of temperature lookup parameters.</p> required <code>cst</code> <code>float</code> <p>Cast shadow time.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Shadow temperature table.</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_shadow_temp_table(\n    temp_table, sun_theta, sun_az, tparams, cst, tlookup=TLOOKUP\n):\n\"\"\"\n    Return shadow temperature for each facet in temp_illum.\n\n    Facets where solar incidence angle &gt; 90 degrees (shaded relief) retain the\n    temp_table value since the sun has simply set in thermal model.\n\n    Facets where solar incidence angle &lt; 90 degrees (cast shadow) are set to a\n    shadow temperature following Bandfield et al. (2018).\n\n    Parameters:\n        temp_table (xr.DataArray): Table of facet temperatures.\n        sun_theta (float): Solar incidence angle.\n        sun_az (float): Solar azimuth.\n        tparams (dict): Dictionary of temperature lookup parameters.\n        cst (float): Cast shadow time.\n\n    Returns:\n        (np.ndarray): Shadow temperature table.\n    \"\"\"\n    tshadow = get_shadow_temp_new(temp_table, tparams, cst, tlookup)\n    # tshadow = get_shadow_temp(sun_theta, sun_az, tflat)\n\n    # Determine where facets are past local sunset (cinc &gt; 0)\n    facet_theta, facet_az = rh.facet_grids(temp_table)\n    cinc = rn.get_facet_cos_theta(facet_theta, facet_az, sun_theta, sun_az)\n    temp_shadow = temp_table.copy()\n\n    # Take normal nighttime temp for facets past sunset\n    # Take tshadow for facets in cast shadow unless normal temp is colder\n    temp_shadow = xr.where(\n        (cinc &lt; 0) | (temp_shadow &lt; tshadow), temp_shadow, tshadow\n    )\n    return temp_shadow\n</code></pre>"},{"location":"reference/emission/#emission.get_solar_irradiance","title":"<code>get_solar_irradiance(solar_spec, solar_dist)</code>","text":"<p>Return solar irradiance from solar spectrum and solar dist assuming lambertian surface.</p> <p>Parameters:</p> Name Type Description Default <code>solar_spec</code> <code>arr</code> <p>Solar spectrum [W m^-2 \u03bcm^-1] at 1 au</p> required <code>solar_dist</code> <code>num</code> <p>Solar distance (au)</p> required Source code in <code>roughness/emission.py</code> <pre><code>def get_solar_irradiance(solar_spec, solar_dist):\n\"\"\"\n    Return solar irradiance from solar spectrum and solar dist\n    assuming lambertian surface.\n\n    Parameters:\n        solar_spec (arr): Solar spectrum [W m^-2 \u03bcm^-1] at 1 au\n        solar_dist (num): Solar distance (au)\n    \"\"\"\n    return solar_spec / (solar_dist**2 * np.pi)\n</code></pre>"},{"location":"reference/emission/#emission.get_temp_sb","title":"<code>get_temp_sb(rad)</code>","text":"<p>Return temperature assuming the Stefan-Boltzmann Law given radiance.</p> <p>Parameters:</p> Name Type Description Default <code>rad</code> <code>num | arr</code> <p>Radiance [W m^-2]</p> required Source code in <code>roughness/emission.py</code> <pre><code>def get_temp_sb(rad):\n\"\"\"\n    Return temperature assuming the Stefan-Boltzmann Law given radiance.\n\n    Parameters:\n        rad (num | arr): Radiance [W m^-2]\n    \"\"\"\n    temp = (rad / SB) ** 0.25\n    if isinstance(rad, xr.DataArray):\n        temp.name = \"Temperature [K]\"\n    return temp\n</code></pre>"},{"location":"reference/emission/#emission.get_temp_table","title":"<code>get_temp_table(params, tlookup=None)</code>","text":"<p>Return 2D temperature table of surface facets (inc, az).</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>Dictionary of temperature lookup parameters.</p> required <code>tlookup</code> <code>path</code> <p>Temperature lookup xarray or path to file.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Facet temperatures (dims: az, theta)</p> Source code in <code>roughness/emission.py</code> <pre><code>def get_temp_table(params, tlookup=None):\n\"\"\"\n    Return 2D temperature table of surface facets (inc, az).\n\n    Parameters:\n        params (dict): Dictionary of temperature lookup parameters.\n        tlookup (path): Temperature lookup xarray or path to file.\n\n    Returns:\n        (np.ndarray): Facet temperatures (dims: az, theta)\n    \"\"\"\n    if tlookup is None:\n        tlookup = TLOOKUP\n    temp_table = rn.get_table_xarr(params, da=\"tsurf\", los_lookup=tlookup)\n    return temp_table\n</code></pre>"},{"location":"reference/emission/#emission.mrad2cmrad","title":"<code>mrad2cmrad(mrad)</code>","text":"<p>Convert radiance from units W/(m^2 sr \u03bcm) to W/(cm^2 sr \u03bcm).</p> Source code in <code>roughness/emission.py</code> <pre><code>def mrad2cmrad(mrad):\n\"\"\"Convert radiance from units W/(m^2 sr \u03bcm) to W/(cm^2 sr \u03bcm).\"\"\"\n    return mrad * 1e-4  # [W/(m^2 sr \u03bcm)] -&gt; [W/(cm^2 sr \u03bcm)]\n</code></pre>"},{"location":"reference/emission/#emission.rough_emission_eq","title":"<code>rough_emission_eq(geom, wls, rms, albedo, emissivity, solar_dist, rerad=False, flookup=None)</code>","text":"<p>Return emission spectrum corrected for subpixel roughness assuming radiative equillibrium. Uses ray-casting generated shadow_lookup table at sl_path.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>list of float</code> <p>View geometry (sun_theta, sun_az, sc_theta, sc_az)</p> required <code>wls</code> <code>arr</code> <p>Wavelengths [microns]</p> required <code>rms</code> <code>arr</code> <p>RMS roughness [degrees]</p> required <code>albedo</code> <code>num</code> <p>Hemispherical broadband albedo</p> required <code>emissivity</code> <code>num</code> <p>Emissivity</p> required <code>solar_dist</code> <code>num</code> <p>Solar distance (au)</p> required <code>rerad</code> <code>bool</code> <p>If True, include re-radiation from adjacent facets</p> <code>False</code> <code>flookup</code> <code>str</code> <p>Los lookup path</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rough_emission</code> <code>arr</code> <p>Emission spectrum vs. wls [W m^-2]</p> Source code in <code>roughness/emission.py</code> <pre><code>def rough_emission_eq(\n    geom, wls, rms, albedo, emissivity, solar_dist, rerad=False, flookup=None\n):\n\"\"\"\n    Return emission spectrum corrected for subpixel roughness assuming\n    radiative equillibrium. Uses ray-casting generated shadow_lookup table at\n    sl_path.\n\n    Parameters:\n        geom (list of float): View geometry (sun_theta, sun_az, sc_theta, sc_az)\n        wls (arr): Wavelengths [microns]\n        rms (arr): RMS roughness [degrees]\n        albedo (num): Hemispherical broadband albedo\n        emissivity (num): Emissivity\n        solar_dist (num): Solar distance (au)\n        rerad (bool): If True, include re-radiation from adjacent facets\n        flookup (str): Los lookup path\n\n    Returns:\n        rough_emission (arr): Emission spectrum vs. wls [W m^-2]\n    \"\"\"\n    sun_theta, sun_az, sc_theta, sc_az = geom\n    if isinstance(wls, np.ndarray):\n        wls = rh.wl2xr(wls)\n    # If no roughness, return isothermal emission\n    if rms == 0:\n        return bb_emission_eq(sun_theta, wls, albedo, emissivity, solar_dist)\n\n    # Select shadow table based on rms, solar incidence and az\n    shadow_table = rn.get_shadow_table(rms, sun_theta, sun_az, flookup)\n    temp_illum = get_facet_temp_illum_eq(\n        shadow_table,\n        sun_theta,\n        sun_az,\n        albedo,\n        emissivity,\n        solar_dist,\n        rerad=rerad,\n    )\n\n    # Compute temperatures for shadowed facets (JB approximation)\n    temp0 = temp_illum[0, 0]  # Temperature of level surface facet\n    temp_shade = get_shadow_temp(sun_theta, sun_az, temp0)\n\n    # Compute 2 component emission of illuminated and shadowed facets\n    emission_table = emission_2component(\n        wls, temp_illum, temp_shade, shadow_table, emissivity\n    )\n\n    # Weight each facet by its probability of occurrance\n    weights = rn.get_weight_table(rms, sun_theta, sc_theta, sc_az, flookup)\n    weights = weights.interp_like(emission_table)\n    weights = weights / weights.sum()\n    rough_emission = emission_spectrum(emission_table, weights)\n    return rough_emission\n</code></pre>"},{"location":"reference/emission/#emission.rough_emission_lookup","title":"<code>rough_emission_lookup(geom, wls, rms=15, tparams=None, rerad=True, flookup=None, tlookup=None, emissivity=1, cast_shadow_time=0.05)</code>","text":"<p>Return rough emission spectrum given geom and params to tlookup.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>list of float</code> <p>Viewing geometry specified as four angles (solar_incidence, solar_azimuth, view_emission, view_azimuth)</p> required <code>wls</code> <code>arr</code> <p>Wavelengths [microns]</p> required <code>rms</code> <code>arr</code> <p>RMS roughness [degrees]. Default is 15.</p> <code>15</code> <code>rerad</code> <code>bool</code> <p>If True, include re-radiation from adjacent facets. Default is True.</p> <code>True</code> <code>tparams</code> <code>dict</code> <p>Dictionary of temperature lookup parameters. Default is None.</p> <code>None</code> <code>flookup</code> <code>path</code> <p>Facet lookup xarray or path to file. Default is None.</p> <code>None</code> <code>tlookup</code> <code>path</code> <p>Temperature lookup xarray or path to file. Default is None.</p> <code>None</code> <code>emissivity</code> <code>float</code> <p>Emissivity. Default is 1.</p> <code>1</code> <code>cast_shadow_time</code> <code>float</code> <p>Time spent in cast shadow as fraction of one day. Default is 0.05.</p> <code>0.05</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Rough emission spectrum.</p> Source code in <code>roughness/emission.py</code> <pre><code>def rough_emission_lookup(\n    geom,\n    wls,\n    rms=15,\n    tparams=None,\n    rerad=True,\n    flookup=None,\n    tlookup=None,\n    emissivity=1,\n    cast_shadow_time=0.05,\n):\n\"\"\"\n    Return rough emission spectrum given geom and params to tlookup.\n\n    Parameters:\n        geom (list of float): Viewing geometry specified as four angles\n            (solar_incidence, solar_azimuth, view_emission, view_azimuth)\n        wls (arr): Wavelengths [microns]\n        rms (arr, optional): RMS roughness [degrees]. Default is 15.\n        rerad (bool, optional): If True, include re-radiation from adjacent\n            facets. Default is True.\n        tparams (dict, optional): Dictionary of temperature lookup parameters.\n            Default is None.\n        flookup (path, optional): Facet lookup xarray or path to\n            file. Default is None.\n        tlookup (path, optional): Temperature lookup xarray or path\n            to file. Default is None.\n        emissivity (float, optional): Emissivity. Default is 1.\n        cast_shadow_time (float, optional): Time spent in cast shadow as\n            fraction of one day. Default is 0.05.\n\n    Returns:\n        (xr.DataArray): Rough emission spectrum.\n    \"\"\"\n    if tparams is None:\n        tparams = {}  # TODO: raise more useful error here\n    sun_theta, sun_az, sc_theta, sc_az = geom\n    if isinstance(wls, np.ndarray):\n        wls = rh.wl2xr(wls)\n\n    # Query los and temperature lookup tables\n    shadow_table = rn.get_shadow_table(rms, sun_theta, sun_az, flookup)\n    # if not shadow_table.isnull().all():\n    # shadow_table = shadow_table.dropna(\"theta\")\n\n    # Get illum and shadowed facet temperatures\n    temp_table = get_temp_table(tparams, tlookup)\n    tflat = temp_table.sel(theta=0, az=0).values\n    # tvert = temp_table.sel(theta=90).interp(az=sun_az).values\n    temp_table = temp_table.interp_like(shadow_table)\n    temp_shade = get_shadow_temp_table(\n        temp_table, sun_theta, sun_az, tparams, cast_shadow_time, tlookup\n    )\n    if rerad:\n        rad_table = get_rad_sb(temp_table)\n        rad_shade = get_rad_sb(temp_shade)\n        albedo = 0.12\n        if \"albedo\" in tparams:\n            albedo = tparams[\"albedo\"]\n        rerad = get_reradiation_jb(sun_theta, rad_table.theta, tflat, albedo)\n        # rerad = get_reradiation_alt(rad_table, sun_theta, sun_az, tflat,\n        #                             tvert, albedo, emissivity)\n        # rerad_new = get_reradiation_new(tflat, albedo, emissivity)\n        temp_table = get_temp_sb(rad_table + rerad)\n        temp_shade = get_temp_sb(rad_shade + rerad)\n\n    # Directional emissivity table\n    # facet_theta, facet_az = rh.facet_grids(temp_table)\n    # emissivity = get_emissivity_table(facet_theta, facet_az, sc_theta, sc_az)\n\n    # Compute 2 component emission of illuminated and shadowed facets\n    emission_table = emission_2component(\n        wls, temp_table, temp_shade, shadow_table, emissivity\n    )\n\n    # Weight each facet by its prob of occurring and being visible from sc\n    # weights = rn.get_weight_table(rms, sun_theta, sc_theta, sc_az, flookup)\n\n    # weights = weights.interp_like(emission_table)\n    # weights = weights / weights.sum()\n\n    view_table = rn.get_view_table(rms, sc_theta, sc_az, flookup)\n    # Get probability each facet exists at given rms\n    facet_weight = rn.get_facet_table(rms, sun_theta, flookup)\n    rough_emission = emission_spectrum(\n        emission_table, facet_weight * view_table\n    )\n    return rough_emission\n</code></pre>"},{"location":"reference/emission/#emission.rough_emission_lookup_new","title":"<code>rough_emission_lookup_new(geom, wls, rms=15, tparams=None, rerad=True, flookup=None, tlookup=None, emissivity=1, cast_shadow_time=0.05)</code>","text":"<p>Return rough emission spectrum given geom and params to tlookup.</p> <p>Parameters:</p> Name Type Description Default <code>geom</code> <code>list of float</code> <p>Viewing geometry specified as four angles (solar_incidence, solar_azimuth, view_emission, view_azimuth)</p> required <code>wls</code> <code>arr</code> <p>Wavelengths [microns]</p> required <code>rms</code> <code>arr</code> <p>RMS roughness [degrees]. Default is 15.</p> <code>15</code> <code>rerad</code> <code>bool</code> <p>If True, include re-radiation from adjacent facets. Default is True.</p> <code>True</code> <code>tparams</code> <code>dict</code> <p>Dictionary of temperature lookup parameters. Default is None.</p> <code>None</code> <code>flookup</code> <code>path</code> <p>Facet lookup xarray or path to file. Default is None.</p> <code>None</code> <code>tlookup</code> <code>path</code> <p>Temperature lookup xarray or path to file. Default is None.</p> <code>None</code> <code>emissivity</code> <code>float</code> <p>Emissivity. Default is 1.</p> <code>1</code> <code>cast_shadow_time</code> <code>float</code> <p>Time spent in cast shadow as fraction of one day. Default is 0.05.</p> <code>0.05</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Rough emission spectrum.</p> Source code in <code>roughness/emission.py</code> <pre><code>def rough_emission_lookup_new(\n    geom,\n    wls,\n    rms=15,\n    tparams=None,\n    rerad=True,\n    flookup=None,\n    tlookup=None,\n    emissivity=1,\n    cast_shadow_time=0.05,\n):\n\"\"\"\n    Return rough emission spectrum given geom and params to tlookup.\n\n    Parameters:\n        geom (list of float): Viewing geometry specified as four angles\n            (solar_incidence, solar_azimuth, view_emission, view_azimuth)\n        wls (arr): Wavelengths [microns]\n        rms (arr, optional): RMS roughness [degrees]. Default is 15.\n        rerad (bool, optional): If True, include re-radiation from adjacent\n            facets. Default is True.\n        tparams (dict, optional): Dictionary of temperature lookup parameters.\n            Default is None.\n        flookup (path, optional): Facet lookup xarray or path to\n            file. Default is None.\n        tlookup (path, optional): Temperature lookup xarray or path\n            to file. Default is None.\n        emissivity (float, optional): Emissivity. Default is 1.\n        cast_shadow_time (float, optional): Time spent in cast shadow as\n            fraction of one day. Default is 0.05.\n\n    Returns:\n        (xr.DataArray): Rough emission spectrum.\n    \"\"\"\n    if tparams is None:\n        tparams = {}  # TODO: raise more useful error here\n    sun_theta, sun_az, sc_theta, sc_az = geom\n    if isinstance(wls, np.ndarray):\n        wls = rh.wl2xr(wls)\n\n    # Query los and temperature lookup tables\n    shadow_table = rn.get_shadow_table(rms, sun_theta, sun_az, flookup)\n\n    # Get illum and shadowed facet temperatures\n    temp_table = get_temp_table(tparams, tlookup)\n    tflat = temp_table.sel(theta=0, az=0).values\n    tvert = temp_table.sel(theta=90).interp(az=sun_az).values\n    temp_table = temp_table.interp_like(shadow_table)\n    temp_shade = get_shadow_temp_table(\n        temp_table, sun_theta, sun_az, tparams, cast_shadow_time, tlookup\n    )\n    rad_table = get_rad_sb(temp_table)\n    rad_shade = get_rad_sb(temp_shade)\n\n    if rerad:\n        albedo = tparams.get(\"albedo\", 0.12)\n        rerad = get_reradiation_alt(\n            rad_table, sun_theta, sun_az, tflat, tvert, albedo, emissivity\n        )\n        print(\n            [\n                f\"{float(v):.0f}\"\n                for v in [rerad.sum(), rad_table.sum(), rad_shade.sum()]\n            ]\n        )\n        rad_table += rerad\n        rad_shade += rerad\n\n    # Get norm factor from weighted hemispherical radiance in view direction\n    rad_tot = rad_table * (1 - shadow_table) + rad_table * shadow_table\n    view_table = rn.get_view_table(rms, sc_theta, sc_az, flookup)\n    # view_table = rn.get_los_table(rms, sc_theta, sc_az, flookup, \"prob\")\n    # view_table = view_table.where(view_table &gt; 0)\n    facet_weight = rn.get_facet_table(rms, sun_theta, flookup)\n    rweighted = rad_tot * facet_weight * view_table\n\n    norm = get_rad_sb(tflat) / float(rweighted.sum(dim=[\"theta\", \"az\"]))\n    # print(f'{tflat:.0f}', norm)\n    rad_table *= norm\n    rad_shade *= norm\n\n    # Convert each facet to effective temperature and compute rad spectrum\n    temp_table = get_temp_sb(rad_table)\n    temp_shade = get_temp_sb(rad_shade)\n    emission_table = emission_2component(\n        wls, temp_table, temp_shade, shadow_table, emissivity\n    )\n    rough_emission = emission_spectrum(\n        emission_table, facet_weight * view_table\n    )\n    return rough_emission\n</code></pre>"},{"location":"reference/emission/#emission.temp2rad","title":"<code>temp2rad(wavelength, temp, emissivity=1)</code>","text":"<p>Return \"graybody\" radiance at temperature and emissivity.</p> Source code in <code>roughness/emission.py</code> <pre><code>def temp2rad(wavelength, temp, emissivity=1):\n\"\"\"\n    Return \"graybody\" radiance at temperature and emissivity.\n    \"\"\"\n    rad = bbrw(wavelength, temp) * emissivity\n    return cmrad2mrad(rad)\n</code></pre>"},{"location":"reference/emission/#emission.wl2wn","title":"<code>wl2wn(wavelength)</code>","text":"<p>Convert wavelength (\u03bcm) to wavenumber (cm-1).</p> Source code in <code>roughness/emission.py</code> <pre><code>def wl2wn(wavelength):\n\"\"\"Convert wavelength (\u03bcm) to wavenumber (cm-1).\"\"\"\n    return 10000 / wavelength\n</code></pre>"},{"location":"reference/emission/#emission.wlrad2wnrad","title":"<code>wlrad2wnrad(wl, wlrad)</code>","text":"<p>Convert radiance from units W/(cm2 sr cm-1) to W/(cm2 sr \u03bcm).</p> Source code in <code>roughness/emission.py</code> <pre><code>def wlrad2wnrad(wl, wlrad):\n\"\"\"\n    Convert radiance from units W/(cm2 sr cm-1) to W/(cm2 sr \u03bcm).\n    \"\"\"\n    wn = 1 / wl  # [\u03bcm] -&gt; [\u03bcm-1]\n    wnrad = wlrad / wn**2  # [1/\u03bcm] -&gt; [1/\u03bcm-1]\n    return wnrad * 1e-4  # [1/\u03bcm-1] -&gt; [1/cm-1]\n</code></pre>"},{"location":"reference/emission/#emission.wn2wl","title":"<code>wn2wl(wavenumber)</code>","text":"<p>Convert wavenumber (cm-1) to wavelength (\u03bcm).</p> Source code in <code>roughness/emission.py</code> <pre><code>def wn2wl(wavenumber):\n\"\"\"Convert wavenumber (cm-1) to wavelength (\u03bcm).\"\"\"\n    return 10000 / wavenumber\n</code></pre>"},{"location":"reference/emission/#emission.wnrad2wlrad","title":"<code>wnrad2wlrad(wavenumber, rad)</code>","text":"<p>Convert radiance from units W/(cm2 sr cm-1) to W/(cm2 sr \u03bcm).</p> <p>Parameters:</p> Name Type Description Default <code>wavenumber</code> <code>num | arr</code> <p>Wavenumber(s) [cm^-1]</p> required <code>rad</code> <code>num | arr</code> <p>Radiance in terms of wn units [W/(cm^2 sr cm^-1)]</p> required Source code in <code>roughness/emission.py</code> <pre><code>def wnrad2wlrad(wavenumber, rad):\n\"\"\"\n    Convert radiance from units W/(cm2 sr cm-1) to W/(cm2 sr \u03bcm).\n\n    Parameters:\n        wavenumber (num | arr): Wavenumber(s) [cm^-1]\n        rad (num | arr): Radiance in terms of wn units [W/(cm^2 sr cm^-1)]\n    \"\"\"\n    wavenumber_microns = wavenumber * 1e-4  # [cm-1] -&gt; [\u03bcm-1]\n    rad_microns = rad * 1e4  # [1/cm-1] -&gt; [1/\u03bcm-1]\n    return rad_microns * wavenumber_microns**2  # [1/\u03bcm-1] -&gt; [1/\u03bcm]\n</code></pre>"},{"location":"reference/helpers/","title":"helpers","text":"<p>Roughness helper functions</p>"},{"location":"reference/helpers/#helpers.as_cart3D","title":"<code>as_cart3D(vecs)</code>","text":"<p>Return list of vecs as shape (N, M, 3) if they are not already.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def as_cart3D(vecs):\n\"\"\"Return list of vecs as shape (N, M, 3) if they are not already.\"\"\"\n    for i, vec in enumerate(vecs):\n        if vec.ndim == 1:\n            vecs[i] = vec[np.newaxis, np.newaxis, :]\n    return vecs\n</code></pre>"},{"location":"reference/helpers/#helpers.build_jupyter_notebooks","title":"<code>build_jupyter_notebooks(nbpath=cfg.EXAMPLES_DIR)</code>","text":"<p>Build Jupyter notebooks using Jupytext.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def build_jupyter_notebooks(nbpath=cfg.EXAMPLES_DIR):\n\"\"\"Build Jupyter notebooks using Jupytext.\"\"\"\n    print(\"Setting up Jupyter notebooks\")\n    for nb_py in nbpath.rglob(\"*.py\"):\n        fout = Path(nb_py).with_suffix(\".ipynb\")\n        if fout.exists():\n            print(f\"Skipping existing notebook {fout}\")\n        else:\n            jupytext.write(jupytext.read(nb_py), fout)\n            print(f\"Wrote {fout}\")\n</code></pre>"},{"location":"reference/helpers/#helpers.cart2pol","title":"<code>cart2pol(x, y)</code>","text":"<p>Convert ordered coordinate pairs from Cartesian (X,Y) to polar (r,theta).</p> <p>Parameters:</p> Name Type Description Default <code>x,y</code> <code>array</code> <p>Cartesian coordinates</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>array</code> <p>Distance from origin.</p> <code>theta</code> <code>array</code> <p>Polar angle, [radians].</p> Source code in <code>roughness/helpers.py</code> <pre><code>def cart2pol(x, y):\n\"\"\"\n    Convert ordered coordinate pairs from Cartesian (X,Y) to polar (r,theta).\n\n    Parameters:\n        x,y (array): Cartesian coordinates\n\n    Returns:\n        r (array): Distance from origin.\n        theta (array): Polar angle, [radians].\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return (r, theta)\n</code></pre>"},{"location":"reference/helpers/#helpers.cart2sph","title":"<code>cart2sph(x, y, z)</code>","text":"<p>Convert from cartesian (x, y, z) to spherical (theta, phi, r).</p> <p>Parameters:</p> Name Type Description Default <code>x,</code> <code>y, z (array</code> <p>Cartesian coordinates.</p> required <p>Returns:</p> Name Type Description <code>theta</code> <code>array</code> <p>Polar angle [rad].</p> <code>phi</code> <code>array</code> <p>Azimuthal angle [rad].</p> <code>radius</code> <code>array</code> <p>Radius.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def cart2sph(x, y, z):\n\"\"\"\n    Convert from cartesian (x, y, z) to spherical (theta, phi, r).\n\n    Parameters:\n        x, y, z (array): Cartesian coordinates.\n\n    Returns:\n        theta (array): Polar angle [rad].\n        phi (array): Azimuthal angle [rad].\n        radius (array): Radius.\n    \"\"\"\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)\n    phi = np.arctan2(y, x)\n    return (theta, phi, r)\n</code></pre>"},{"location":"reference/helpers/#helpers.change_working_directory","title":"<code>change_working_directory(path)</code>","text":"<p>Change working directory and revert to previous on exit.</p> Source code in <code>roughness/helpers.py</code> <pre><code>@contextlib.contextmanager\ndef change_working_directory(path):\n\"\"\"Change working directory and revert to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)\n</code></pre>"},{"location":"reference/helpers/#helpers.check_data_updated","title":"<code>check_data_updated()</code>","text":"<p>Check if data version is up to date.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def check_data_updated():\n\"\"\"Check if data version is up to date.\"\"\"\n    version = get_data_version()\n    if version is None or not versions_match(version, cfg.__version__):\n        print(\"WARNING: The roughness/data folder is not up to date!\")\n        print(\"Update to the newest lookup tables with -d flag.\")\n        return False\n    return True\n</code></pre>"},{"location":"reference/helpers/#helpers.compile_lineofsight","title":"<code>compile_lineofsight(los_f90=cfg.FLOS_F90, verbose=False)</code>","text":"<p>Compile lineofsight module with numpy f2py. Error if no compiler.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def compile_lineofsight(los_f90=cfg.FLOS_F90, verbose=False):\n\"\"\"Compile lineofsight module with numpy f2py. Error if no compiler.\"\"\"\n    with open(los_f90, encoding=\"utf8\") as f:\n        src = f.read()\n    failed = numpy.f2py.compile(\n        src, \"lineofsight\", verbose=verbose, source_fn=los_f90\n    )\n    if failed:\n        msg = \"Cannot compile Fortran raytracing code. Please ensure you have \\\n               a F90 compatible Fortran compiler (e.g. gfortran) installed.\"\n        raise ImportError(msg)\n</code></pre>"},{"location":"reference/helpers/#helpers.element_cross","title":"<code>element_cross(A, B)</code>","text":"<p>Return element-wise cross product of two 3D arrays in cartesian coords.</p> <p>Parameters:</p> Name Type Description Default <code>A,</code> <code>B (array</code> <p>3D arrays of vectors in cartesian coords.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array</code> <p>3D array of vector cross products in cartesian coords.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def element_cross(A, B):\n\"\"\"\n    Return element-wise cross product of two 3D arrays in cartesian coords.\n\n    Parameters:\n        A, B (array): 3D arrays of vectors in cartesian coords.\n\n    Returns:\n        out (array): 3D array of vector cross products in cartesian coords.\n    \"\"\"\n    A, B = as_cart3D([A, B])\n    out = np.zeros_like(A)\n    out[:, :, 0] = A[:, :, 1] * B[:, :, 2] - A[:, :, 2] * B[:, :, 1]\n    out[:, :, 1] = A[:, :, 2] * B[:, :, 0] - A[:, :, 0] * B[:, :, 2]\n    out[:, :, 2] = A[:, :, 0] * B[:, :, 1] - A[:, :, 1] * B[:, :, 0]\n    return out\n</code></pre>"},{"location":"reference/helpers/#helpers.element_dot","title":"<code>element_dot(A, B)</code>","text":"<p>Return element-wise dot product of two 3D arrays in Cartesian coords.</p> <p>Parameters:</p> Name Type Description Default <code>A,</code> <code>B (array</code> <p>3D arrays of vectors in cartesian coords.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array</code> <p>2D array of vector dot products.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def element_dot(A, B):\n\"\"\"\n    Return element-wise dot product of two 3D arrays in Cartesian coords.\n\n    Parameters:\n        A, B (array): 3D arrays of vectors in cartesian coords.\n\n    Returns:\n        out (array): 2D array of vector dot products.\n    \"\"\"\n    A, B = as_cart3D([A, B])\n    return np.sum(A * B, axis=2)\n</code></pre>"},{"location":"reference/helpers/#helpers.element_norm","title":"<code>element_norm(A)</code>","text":"<p>Return input array of vectors normalized to length 1.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>array</code> <p>3D array of vectors in cartesian coords.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array</code> <p>3D array of normalized vectors.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def element_norm(A):\n\"\"\"\n    Return input array of vectors normalized to length 1.\n\n    Parameters:\n        A (array): 3D array of vectors in cartesian coords.\n\n    Returns:\n        out (array): 3D array of normalized vectors.\n    \"\"\"\n    A = as_cart3D([A])[0]\n    mag = np.sqrt(np.sum(A**2, axis=2))\n    return A / mag[:, :, np.newaxis]\n</code></pre>"},{"location":"reference/helpers/#helpers.element_triple_cross","title":"<code>element_triple_cross(A, B, C)</code>","text":"<p>Return element-wise triple cross product of three 3D arr in Cartesian</p> <p>Parameters:</p> Name Type Description Default <code>A,</code> <code>B, C (array</code> <p>3D arrays of vectors in cartesian coords.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array</code> <p>3D array of triple cross products.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def element_triple_cross(A, B, C):\n\"\"\"\n    Return element-wise triple cross product of three 3D arr in Cartesian\n\n    Parameters:\n        A, B, C (array): 3D arrays of vectors in cartesian coords.\n\n    Returns:\n        out (array): 3D array of triple cross products.\n    \"\"\"\n    A, B, C = as_cart3D([A, B, C])\n    return (\n        B * (element_dot(A, C))[:, :, np.newaxis]\n        - C * (element_dot(A, B))[:, :, np.newaxis]\n    )\n</code></pre>"},{"location":"reference/helpers/#helpers.facet_grids","title":"<code>facet_grids(los_table, units='degrees')</code>","text":"<p>Return 2D grids of surface facet slope and azimuth angles of los_table.</p> <p>Assumes los_table axes are (az, theta) with ranges:     az: [0, 360] degrees     theta: [0, 90] degrees</p> <p>Parameters:</p> Name Type Description Default <code>los_table</code> <code>arr</code> <p>Line of sight table (dims: az, theta)</p> required <code>units</code> <code>str</code> <p>Return grids in specified units ('degrees' or 'radians')</p> <code>'degrees'</code>"},{"location":"reference/helpers/#helpers.facet_grids--return","title":"Return","text":"<pre><code>thetas, azs (tuple of 2D array): Coord grids of facet slope and az\n</code></pre> Source code in <code>roughness/helpers.py</code> <pre><code>def facet_grids(los_table, units=\"degrees\"):\n\"\"\"\n    Return 2D grids of surface facet slope and azimuth angles of los_table.\n\n    Assumes los_table axes are (az, theta) with ranges:\n        az: [0, 360] degrees\n        theta: [0, 90] degrees\n\n    Parameters:\n        los_table (arr): Line of sight table (dims: az, theta)\n        units (str): Return grids in specified units ('degrees' or 'radians')\n\n    Return\n    ------\n        thetas, azs (tuple of 2D array): Coord grids of facet slope and az\n    \"\"\"\n    if isinstance(los_table, xr.DataArray):\n        az_arr = los_table.az.values\n        theta_arr = los_table.theta.values\n    else:\n        naz, ntheta = los_table.shape\n        _, _, az_arr, theta_arr = get_lookup_coords(naz=naz, ntheta=ntheta)\n    if units == \"radians\":\n        az_arr = np.radians(az_arr)\n        theta_arr = np.radians(theta_arr)\n\n    # Make coordinate grids\n    theta_grid, az_grid = np.meshgrid(theta_arr, az_arr)\n    if isinstance(los_table, xr.DataArray):\n        theta_grid = xr.DataArray(\n            theta_grid,\n            dims=[\"az\", \"theta\"],\n            coords={\"az\": az_arr, \"theta\": theta_arr},\n        )\n        theta_grid.name = f\"theta [{units}]\"\n        az_grid = xr.DataArray(\n            az_grid,\n            dims=[\"az\", \"theta\"],\n            coords={\"az\": az_arr, \"theta\": theta_arr},\n        )\n        az_grid.name = f\"azimuth [{units}]\"\n    return theta_grid, az_grid\n</code></pre>"},{"location":"reference/helpers/#helpers.fname_with_demsize","title":"<code>fname_with_demsize(filename, demsize)</code>","text":"<p>Return filename with demsize appended to the end.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str or Path</code> <p>Filename to append to.</p> required <code>demsize</code> <code>int</code> <p>Length of dem in pixels.</p> required <p>Returns:</p> Name Type Description <code>fname_with_demsize</code> <code>str</code> <p>New filename with new demsize appended.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def fname_with_demsize(filename, demsize):\n\"\"\"\n    Return filename with demsize appended to the end.\n\n    Parameters:\n        fname (str or Path): Filename to append to.\n        demsize (int): Length of dem in pixels.\n\n    Returns:\n        fname_with_demsize (str): New filename with new demsize appended.\n    \"\"\"\n    filename = Path(filename)\n    return filename.with_name(f\"{filename.stem}_s{demsize}{filename.suffix}\")\n</code></pre>"},{"location":"reference/helpers/#helpers.get_angle_between","title":"<code>get_angle_between(vec1, vec2, safe_arccos=False)</code>","text":"<p>Return angle between cartesian vec1 and vec2 using dot product.</p> <p>If vec1 or vec2 are NxMx3, compute element-wise.</p> <p>Parameters:</p> Name Type Description Default <code>vec1,</code> <code>vec2 (array</code> <p>Cartesian vectors.</p> required <code>safe_arccos</code> <code>bool</code> <p>Clip dot product to [-1, 1] before arccos.</p> <code>False</code> Source code in <code>roughness/helpers.py</code> <pre><code>def get_angle_between(vec1, vec2, safe_arccos=False):\n\"\"\"\n    Return angle between cartesian vec1 and vec2 using dot product.\n\n    If vec1 or vec2 are NxMx3, compute element-wise.\n\n    Parameters:\n        vec1, vec2 (array): Cartesian vectors.\n        safe_arccos (bool): Clip dot product to [-1, 1] before arccos.\n    \"\"\"\n    if isinstance(vec1, xr.DataArray) or isinstance(vec2, xr.DataArray):\n        return get_angle_between_xr(vec1, vec2, safe_arccos)\n    dot = element_dot(vec1, vec2)\n    if safe_arccos:\n        # Restrict dot product to [-1, 1] to safely pass to arccos\n        dot = np.clip(dot, -1, 1)\n    return np.rad2deg(np.arccos(dot))\n</code></pre>"},{"location":"reference/helpers/#helpers.get_angle_between_xr","title":"<code>get_angle_between_xr(vec1, vec2, safe_arccos=False)</code>","text":"<p>Return angle between cartesian DataArrays using dot product.</p> <p>Parameters:</p> Name Type Description Default <code>vec1,</code> <code>vec2 (DataArray</code> <p>Cartesian vectors.</p> required <code>safe_arccos</code> <code>bool</code> <p>Clip dot product to [-1, 1] before arccos.</p> <code>False</code> Source code in <code>roughness/helpers.py</code> <pre><code>def get_angle_between_xr(vec1, vec2, safe_arccos=False):\n\"\"\"\n    Return angle between cartesian DataArrays using dot product.\n\n    Parameters:\n        vec1, vec2 (DataArray): Cartesian vectors.\n        safe_arccos (bool): Clip dot product to [-1, 1] before arccos.\n    \"\"\"\n    dot = vec1.dot(vec2, dims=\"xyz\")\n    if safe_arccos:\n        # Restrict dot product to [-1, 1] to safely pass to arccos\n        dot = dot.clip(-1, 1)\n    return np.rad2deg(np.arccos(dot))\n</code></pre>"},{"location":"reference/helpers/#helpers.get_azim","title":"<code>get_azim(ground_sc_ground, ground_sun_ground)</code>","text":"<p>Return the azimuth arccos(dot product of the spacecraft and sun vectors)</p> <p>Parameters:</p> Name Type Description Default <code>ground_sc_ground</code> <code>array</code> <p>Ground to spacecraft vector.</p> required <code>ground_sun_ground</code> <code>array</code> <p>Ground to sun vector.</p> required Source code in <code>roughness/helpers.py</code> <pre><code>def get_azim(ground_sc_ground, ground_sun_ground):\n\"\"\"\n    Return the azimuth arccos(dot product of the spacecraft and sun vectors)\n\n    Parameters:\n        ground_sc_ground (array): Ground to spacecraft vector.\n        ground_sun_ground (array): Ground to sun vector.\n    \"\"\"\n    dot_azim = np.degrees(\n        np.arccos(np.sum(ground_sc_ground * ground_sun_ground, axis=2))\n    )\n    oob = dot_azim[(dot_azim &lt; 0) * (dot_azim &gt; 180)]\n    if oob.any():\n        w = f\"Azimuth {oob} outside (0, 180); Setting to 0\"\n        print(w)\n        dot_azim[(dot_azim &lt; 0) * (dot_azim &gt; 180)] = 0\n    return dot_azim\n</code></pre>"},{"location":"reference/helpers/#helpers.get_data_version","title":"<code>get_data_version(data_version_file=cfg.FDATA_VERSION)</code>","text":"<p>Get data version in data/data_version.txt.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_data_version(data_version_file=cfg.FDATA_VERSION):\n\"\"\"Get data version in data/data_version.txt.\"\"\"\n    data_version = None\n    try:\n        with open(data_version_file, \"r\", encoding=\"utf8\") as f:\n            data_version = f.readline().strip()\n    except FileNotFoundError:\n        pass\n    return data_version\n</code></pre>"},{"location":"reference/helpers/#helpers.get_facet_bins","title":"<code>get_facet_bins(naz=36, ntheta=45)</code>","text":"<p>Return az, theta bin arrays of los_table.</p> <p>Assumes los_table axes are (az, theta) with ranges:     az: [0, 360] degrees     theta: [0, 90] degrees</p> <p>Parameters:</p> Name Type Description Default <code>los_table</code> <code>array</code> <p>Line of sight table (dims: az, theta)</p> required <code>units</code> <code>str</code> <p>Return grids in specified units ('degrees' or 'radians')</p> required"},{"location":"reference/helpers/#helpers.get_facet_bins--return","title":"Return","text":"<pre><code>thetas, azs (tuple of 2D array): Bin edges of facet slope and az\n</code></pre> Source code in <code>roughness/helpers.py</code> <pre><code>def get_facet_bins(naz=36, ntheta=45):\n\"\"\"\n    Return az, theta bin arrays of los_table.\n\n    Assumes los_table axes are (az, theta) with ranges:\n        az: [0, 360] degrees\n        theta: [0, 90] degrees\n\n    Parameters:\n        los_table (array): Line of sight table (dims: az, theta)\n        units (str): Return grids in specified units ('degrees' or 'radians')\n\n    Return\n    ------\n        thetas, azs (tuple of 2D array): Bin edges of facet slope and az\n    \"\"\"\n    azim_coords = np.linspace(0, 360, naz + 1)\n    slope_coords = np.linspace(0, 90, ntheta + 1)\n    return (azim_coords, slope_coords)\n</code></pre>"},{"location":"reference/helpers/#helpers.get_ieg","title":"<code>get_ieg(ground_zen, ground_az, sun_zen, sun_az, sc_zen, sc_az)</code>","text":"<p>Return local solar incidence, spacecraft emergence and phase angles  (i, e, g) and azimuth given input viewing geometry.</p> <p>Input zeniths and azimuths in radians.</p> <p>Parameters:</p> Name Type Description Default <code>ground_zen</code> <code>float</code> <p>Ground zenith angle [rad].</p> required <code>ground_az</code> <code>float</code> <p>Ground azimuth angle [rad].</p> required <code>sun_zen</code> <code>float</code> <p>Sun zenith angle [rad].</p> required <code>sun_az</code> <code>float</code> <p>Sun azimuth angle [rad].</p> required <code>sc_zen</code> <code>float</code> <p>Spacecraft zenith angle [rad].</p> required <code>sc_az</code> <code>float</code> <p>Spacecraft azimuth angle [rad].</p> required <p>Returns:</p> Type Description <code>i, e, g, az) (tuple of float</code> <p>Geometry relative to ground.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_ieg(ground_zen, ground_az, sun_zen, sun_az, sc_zen, sc_az):\n\"\"\"\n    Return local solar incidence, spacecraft emergence and phase angles \n    (i, e, g) and azimuth given input viewing geometry.\n\n    Input zeniths and azimuths in radians.\n\n    Parameters:\n        ground_zen (float): Ground zenith angle [rad].\n        ground_az (float): Ground azimuth angle [rad].\n        sun_zen (float): Sun zenith angle [rad].\n        sun_az (float): Sun azimuth angle [rad].\n        sc_zen (float): Spacecraft zenith angle [rad].\n        sc_az (float): Spacecraft azimuth angle [rad].\n\n    Returns:\n        (i, e, g, az) (tuple of float): Geometry relative to ground.\n    \"\"\"\n    ground = sph2cart(ground_zen, ground_az)\n    sun = sph2cart(sun_zen, sun_az)\n    sc = sph2cart(sc_zen, sc_az)\n    inc = get_angle_between(ground, sun, True)\n    em = get_angle_between(ground, sc, True)\n    phase = get_angle_between(sun, sc, True)\n    sun_sc_az = get_local_az(ground, sun, sc)\n    return (inc, em, phase, sun_sc_az)\n</code></pre>"},{"location":"reference/helpers/#helpers.get_ieg_xr","title":"<code>get_ieg_xr(ground_zen, ground_az, sun_zen, sun_az, sc_zen, sc_az)</code>","text":"<p>Return local solar incidence, spacecraft emergence and phase angles  (i, e, g) and azimuth given input viewing geometry as xarray.DataArray.</p> <p>Input zeniths and azimuths in radians.</p> <p>Parameters:</p> Name Type Description Default <code>ground_zen</code> <code>DataArray</code> <p>Ground zenith angle [rad].</p> required <code>ground_az</code> <code>DataArray</code> <p>Ground azimuth angle [rad].</p> required <code>sun_zen</code> <code>DataArray</code> <p>Sun zenith angle [rad].</p> required <code>sun_az</code> <code>DataArray</code> <p>Sun azimuth angle [rad].</p> required <code>sc_zen</code> <code>DataArray</code> <p>Spacecraft zenith angle [rad].</p> required <code>sc_az</code> <code>DataArray</code> <p>Spacecraft azimuth angle [rad].</p> required <p>Returns:</p> Type Description <code>i, e, g, az) (tuple of DataArray</code> <p>Geometry relative to ground.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_ieg_xr(ground_zen, ground_az, sun_zen, sun_az, sc_zen, sc_az):\n\"\"\"\n    Return local solar incidence, spacecraft emergence and phase angles \n    (i, e, g) and azimuth given input viewing geometry as xarray.DataArray.\n\n    Input zeniths and azimuths in radians.\n\n    Parameters:\n        ground_zen (DataArray): Ground zenith angle [rad].\n        ground_az (DataArray): Ground azimuth angle [rad].\n        sun_zen (DataArray): Sun zenith angle [rad].\n        sun_az (DataArray): Sun azimuth angle [rad].\n        sc_zen (DataArray): Spacecraft zenith angle [rad].\n        sc_az (DataArray): Spacecraft azimuth angle [rad].\n\n    Returns:\n        (i, e, g, az) (tuple of DataArray): Geometry relative to ground.\n    \"\"\"\n    ground = sph2cart_xr(ground_zen, ground_az)\n    sun = sph2cart_xr(sun_zen, sun_az)\n    sc = sph2cart_xr(sc_zen, sc_az)\n    inc = get_angle_between_xr(ground, sun, True)\n    em = get_angle_between_xr(ground, sc, True)\n    phase = get_angle_between_xr(sun, sc, True)\n    sun_sc_az = get_local_az_xr(ground, sun, sc)\n    return inc, em, phase, sun_sc_az\n</code></pre>"},{"location":"reference/helpers/#helpers.get_inc_az_from_subspacecraft","title":"<code>get_inc_az_from_subspacecraft(sslon, sslat, lon, lat)</code>","text":"<p>Return inc and az angle at (lat, lon) given subspacecraft point (sslat, sslon). Return azimuth in degrees Clockwise from North (0 - 360).</p> <p>From calculator at https://the-moon.us/wiki/Sun_Angle</p> <p>Parameters:</p> Name Type Description Default <code>sslon</code> <code>float</code> <p>Subsolar longitude [deg]</p> required <code>sslat</code> <code>float</code> <p>Subsolar latitude [deg]</p> required <code>lon</code> <code>float</code> <p>Longitude of point of interest [deg]</p> required <code>lat</code> <code>float</code> <p>Latitude of point of interest [deg]</p> required <p>Returns:</p> Type Description <p>inc, az (float): Solar incidence and azimuth angles [deg]</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_inc_az_from_subspacecraft(sslon, sslat, lon, lat):\n\"\"\"\n    Return inc and az angle at (lat, lon) given subspacecraft point\n    (sslat, sslon). Return azimuth in degrees Clockwise from North (0 - 360).\n\n    From calculator at https://the-moon.us/wiki/Sun_Angle\n\n    Parameters:\n        sslon (float): Subsolar longitude [deg]\n        sslat (float): Subsolar latitude [deg]\n        lon (float): Longitude of point of interest [deg]\n        lat (float): Latitude of point of interest [deg]\n\n\n    Returns:\n        inc, az (float): Solar incidence and azimuth angles [deg]\n    \"\"\"\n    lon, lat, sslon, sslat, dlon = (\n        np.deg2rad(lon),\n        np.deg2rad(lat),\n        np.deg2rad(sslon),\n        np.deg2rad(sslat),\n        np.deg2rad(lon - sslon),\n    )\n    inc = np.arccos(\n        np.sin(sslat) * np.sin(lat)\n        + np.cos(sslat) * np.cos(lat) * np.cos(dlon)\n    )\n    az = np.arctan2(\n        np.cos(lat) * np.sin(dlon),\n        np.cos(sslat) * np.sin(lat)\n        - np.sin(sslat) * np.cos(lat) * np.cos(dlon),\n    )\n    return np.rad2deg(inc), np.rad2deg(az) % 360\n</code></pre>"},{"location":"reference/helpers/#helpers.get_local_az","title":"<code>get_local_az(ground, sun, sc)</code>","text":"<p>Return azimuth angle of the spacecraft with respect to the sun and local slope. Assumes inputs are same size and shape and are in 3D Cartesian coords (ixjxk).</p> <p>Parameters:</p> Name Type Description Default <code>ground</code> <code>array</code> <p>Ground vector.</p> required <code>sun</code> <code>array</code> <p>Sun vector.</p> required <code>sc</code> <code>array</code> <p>Spacecraft vector.</p> required Source code in <code>roughness/helpers.py</code> <pre><code>def get_local_az(ground, sun, sc):\n\"\"\"\n    Return azimuth angle of the spacecraft with respect to the sun and local\n    slope. Assumes inputs are same size and shape and are in 3D\n    Cartesian coords (ixjxk).\n\n    Parameters:\n        ground (array): Ground vector.\n        sun (array): Sun vector.\n        sc (array): Spacecraft vector.\n    \"\"\"\n    sc_rel_ground = element_norm(element_triple_cross(ground, sc, ground))\n    sun_rel_ground = element_norm(element_triple_cross(ground, sun, ground))\n    az = get_angle_between(sc_rel_ground, sun_rel_ground, True)\n    az[((az &lt; 0) &amp; (az &gt; 180)) | np.isnan(az)] = 0\n    return az\n</code></pre>"},{"location":"reference/helpers/#helpers.get_local_az_xr","title":"<code>get_local_az_xr(ground, sun, sc)</code>","text":"<p>Return azimuth angle of the spacecraft with respect to the sun and local slope. Assumes inputs are same size and shape and are in 3D Cartesian coords (ixjxk).</p> <p>Parameters:</p> Name Type Description Default <code>ground</code> <code>DataArray</code> <p>Ground vector.</p> required <code>sun</code> <code>DataArray</code> <p>Sun vector.</p> required <code>sc</code> <code>DataArray</code> <p>Spacecraft vector.</p> required Source code in <code>roughness/helpers.py</code> <pre><code>def get_local_az_xr(ground, sun, sc):\n\"\"\"\n    Return azimuth angle of the spacecraft with respect to the sun and local\n    slope. Assumes inputs are same size and shape and are in 3D\n    Cartesian coords (ixjxk).\n\n    Parameters:\n        ground (DataArray): Ground vector.\n        sun (DataArray): Sun vector.\n        sc (DataArray): Spacecraft vector.\n    \"\"\"\n    sc_rel_ground = inc_rel_ground_xr(sc, ground)\n    sun_rel_ground = inc_rel_ground_xr(sun, ground)\n    az = get_angle_between_xr(sc_rel_ground, sun_rel_ground, True)\n    az = az.where(((az &gt;= 0) &amp; (az &lt;= 180)))\n    return az\n</code></pre>"},{"location":"reference/helpers/#helpers.get_lookup_bins","title":"<code>get_lookup_bins(nrms=10, ninc=10, naz=36, ntheta=45)</code>","text":"<p>Return coordinate arrays corresponding to number of elements in each axis.</p> Return lookup axes in the following order with ranges <p>rms: [0, 50] degrees inc: [0, 90] degrees az: [0, 360] degrees theta: [0, 90] degrees</p> <p>Parameters:</p> Name Type Description Default <code>nrms</code> <code>int</code> <p>Number of RMS slopes in [0, 50] degrees.</p> <code>10</code> <code>ninc</code> <code>int</code> <p>Number of incidence angles in [0, 90] degrees.</p> <code>10</code> <code>naz</code> <code>int</code> <p>Number of facet azimuth bins in [0, 360] degrees.</p> <code>36</code> <code>ntheta</code> <code>int</code> <p>Number of facet slope bins in [0, 90] degrees.</p> <code>45</code>"},{"location":"reference/helpers/#helpers.get_lookup_bins--return","title":"Return","text":"<p>lookup_coords (tuple of array): Coordinate bins (rms, cinc, az, theta)</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_lookup_bins(nrms=10, ninc=10, naz=36, ntheta=45):\n\"\"\"\n    Return coordinate arrays corresponding to number of elements in each axis.\n\n    Return lookup axes in the following order with ranges:\n        rms: [0, 50] degrees\n        inc: [0, 90] degrees\n        az: [0, 360] degrees\n        theta: [0, 90] degrees\n\n    Parameters:\n        nrms (int): Number of RMS slopes in [0, 50] degrees.\n        ninc (int): Number of incidence angles in [0, 90] degrees.\n        naz (int): Number of facet azimuth bins in [0, 360] degrees.\n        ntheta (int): Number of facet slope bins in [0, 90] degrees.\n\n    Return\n    ------\n    lookup_coords (tuple of array): Coordinate bins (rms, cinc, az, theta)\n    \"\"\"\n    rms_coords = np.linspace(0, 45, nrms)\n    cinc_coords = np.linspace(1, 0, ninc)  # cos([0, 90] degrees)\n    azim_coords = np.linspace(0, 360, naz + 1)\n    slope_coords = np.linspace(0, 90, ntheta + 1)\n    inc_coords = np.rad2deg(np.arccos(cinc_coords))\n    return (rms_coords, inc_coords, azim_coords, slope_coords)\n</code></pre>"},{"location":"reference/helpers/#helpers.get_lookup_coords","title":"<code>get_lookup_coords(nrms=10, ninc=10, naz=36, ntheta=45)</code>","text":"<p>Return lookup table coordinate arrays</p> <p>Parameters:</p> Name Type Description Default <code>nrms</code> <code>int</code> <p>Number of RMS slopes in [0, 50] degrees.</p> <code>10</code> <code>ninc</code> <code>int</code> <p>Number of incidence angles in [0, 90] degrees.</p> <code>10</code> <code>naz</code> <code>int</code> <p>Number of facet azimuth bins in [0, 360] degrees.</p> <code>36</code> <code>ntheta</code> <code>int</code> <p>Number of facet slope bins in [0, 90] degrees.</p> <code>45</code> <p>Returns:</p> Name Type Description <code>lookup_coords</code> <code>list of array</code> <p>Coord arrays (rms, cinc, az, theta)</p> Source code in <code>roughness/helpers.py</code> <pre><code>def get_lookup_coords(nrms=10, ninc=10, naz=36, ntheta=45):\n\"\"\"\n    Return lookup table coordinate arrays\n\n    Parameters:\n        nrms (int): Number of RMS slopes in [0, 50] degrees.\n        ninc (int): Number of incidence angles in [0, 90] degrees.\n        naz (int): Number of facet azimuth bins in [0, 360] degrees.\n        ntheta (int): Number of facet slope bins in [0, 90] degrees.\n\n    Returns:\n        lookup_coords (list of array): Coord arrays (rms, cinc, az, theta)\n    \"\"\"\n    rmss, incs, azs, thetas = get_lookup_bins(nrms, ninc, naz, ntheta)\n    # Get slope and az bin centers\n    azs = (azs[:-1] + azs[1:]) / 2\n    thetas = (thetas[:-1] + thetas[1:]) / 2\n    return [rmss, incs, azs, thetas]\n</code></pre>"},{"location":"reference/helpers/#helpers.import_lineofsight","title":"<code>import_lineofsight(fortran_dir=cfg.FORTRAN_DIR)</code>","text":"<p>Import lineofsight module. Compile first if not found.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def import_lineofsight(fortran_dir=cfg.FORTRAN_DIR):\n\"\"\"Import lineofsight module. Compile first if not found.\"\"\"\n    # pragma pylint: disable=import-outside-toplevel\n    lineofsight = None\n    with change_working_directory(fortran_dir):\n        try:\n            from .fortran import lineofsight\n        except (ImportError, ModuleNotFoundError):\n            try:\n                compile_lineofsight()\n                from .fortran import lineofsight\n            except (ImportError, ModuleNotFoundError):\n                msg = \"Cannot compile lineofsight FORTRAN module. Please \\\n                       ensure you have a F90 compatible Fortran compiler (e.g.\\\n                       gfortran) installed.\"\n                print(msg)\n    return lineofsight\n</code></pre>"},{"location":"reference/helpers/#helpers.inc_rel_ground_xr","title":"<code>inc_rel_ground_xr(vec, ground)</code>","text":"<p>Return vec relative to ground vector.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def inc_rel_ground_xr(vec, ground):\n\"\"\"Return vec relative to ground vector.\"\"\"\n    cross = triple_cross_xr(ground, vec, ground)\n    # Normalize vector by magnitude\n    mag = np.sqrt((cross**2).sum(dim=\"xyz\"))\n    return cross / mag\n</code></pre>"},{"location":"reference/helpers/#helpers.inc_to_tloc","title":"<code>inc_to_tloc(inc, az, lat)</code>","text":"<p>Convert solar incidence and az to decimal local time (in 6-18h).</p> <p>Parameters:</p> Name Type Description Default <code>inc</code> <code>float</code> <p>Solar incidence in degrees [0, 90)</p> required <code>az</code> <code>float</code> <p>Solar azimuth in degrees [0, 360)</p> required <code>lat</code> <code>float</code> <p>Latitude in degrees [-90, 90)</p> required Source code in <code>roughness/helpers.py</code> <pre><code>def inc_to_tloc(inc, az, lat):\n\"\"\"\n    Convert solar incidence and az to decimal local time (in 6-18h).\n\n    Parameters:\n        inc (float): Solar incidence in degrees [0, 90)\n        az (float): Solar azimuth in degrees [0, 360)\n        lat (float): Latitude in degrees [-90, 90)\n    \"\"\"\n    inc, lat = np.deg2rad(inc), np.deg2rad(lat)\n    hr_angle = np.arccos(np.cos(inc) / np.cos(lat))\n    if isinstance(az, xr.DataArray):\n        hr_angle = hr_angle.where(az % 360 &gt; 180, hr_angle * -1)\n    elif isinstance(az, np.ndarray):\n        hr_angle[az % 360 &lt; 180] *= -1\n    elif az % 360 &lt; 180:\n        hr_angle *= -1\n    tloc = 12 + np.rad2deg(hr_angle) / 15\n    return tloc\n</code></pre>"},{"location":"reference/helpers/#helpers.lookup2xarray","title":"<code>lookup2xarray(lookups, rms_coords=None, inc_coords=None, nodata=-999)</code>","text":"<p>Convert list of default lookups to xarray.DataSet.</p> <p>Parameters:</p> Name Type Description Default <code>lookups</code> <code>array</code> <p>Lookup tables (e.g. from make_los_table).</p> required <code>rms_coords</code> <code>array</code> <p>RMS slope coordinates (default: None).</p> <code>None</code> <code>inc_coords</code> <code>array</code> <p>Incidence angle coordinates (default: None).</p> <code>None</code> <code>nodata</code> <code>float</code> <p>Value to replace NaNs with (default: -999).</p> <code>-999</code> <p>Returns:</p> Type Description <p>xarray.DataArray: xarray.DataArray with labeled dims and coords.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def lookup2xarray(lookups, rms_coords=None, inc_coords=None, nodata=-999):\n\"\"\"\n    Convert list of default lookups to xarray.DataSet.\n\n    Parameters:\n        lookups (array): Lookup tables (e.g. from make_los_table).\n        rms_coords (array): RMS slope coordinates (default: None).\n        inc_coords (array): Incidence angle coordinates (default: None).\n        nodata (float): Value to replace NaNs with (default: -999).\n\n    Returns:\n        xarray.DataArray: xarray.DataArray with labeled dims and coords.\n    \"\"\"\n    names = cfg.LUT_NAMES\n    longnames = cfg.LUT_LONGNAMES\n    coords = get_lookup_coords(*lookups[0].shape)\n    if rms_coords is not None:\n        coords[0] = np.array(rms_coords)\n    if inc_coords is not None:\n        coords[1] = np.array(inc_coords)\n    for i, lut in enumerate(lookups):\n        # Make DataArray\n        da = np2xr(lut, name=names[i], coords=coords)\n        da.attrs[\"long_name\"] = longnames[i]\n\n        # Add DataArray to DataSet\n        if i == 0:\n            ds = da.to_dataset()\n        else:\n            ds[names[i]] = da\n    return ds.where(ds != nodata)\n</code></pre>"},{"location":"reference/helpers/#helpers.np2xr","title":"<code>np2xr(arr, dims=None, coords=None, name=None, cnames=None, cunits=None)</code>","text":"<p>Convert numpy array to xarray.DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>array</code> <p>Numpy array to convert to xarray.DataArray.</p> required <code>dims</code> <code>list of str</code> <p>Dimension names (default: cfg.LUT_DIMS).</p> <code>None</code> <code>coords</code> <code>list of arr</code> <p>Coordinate arrays of each dim.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of xarray.DataArray (default: None)</p> <code>None</code> <code>cnames</code> <code>list of str</code> <p>Coordinate names of each param.</p> <code>None</code> <code>cunits</code> <code>list of str</code> <p>Coordinate units of each param (default: deg).</p> <code>None</code> <p>Returns:</p> Type Description <p>xarray.DataArray</p> Source code in <code>roughness/helpers.py</code> <pre><code>def np2xr(arr, dims=None, coords=None, name=None, cnames=None, cunits=None):\n\"\"\"\n    Convert numpy array to xarray.DataArray.\n\n    Parameters:\n        array (np.array): Numpy array to convert to xarray.DataArray.\n        dims (list of str): Dimension names (default: cfg.LUT_DIMS).\n        coords (list of arr): Coordinate arrays of each dim.\n        name (str): Name of xarray.DataArray (default: None)\n        cnames (list of str): Coordinate names of each param.\n        cunits (list of str): Coordinate units of each param (default: deg).\n\n    Returns:\n        xarray.DataArray\n    \"\"\"\n    ndims = len(arr.shape)\n    if dims is None:\n        dims = cfg.LUT_DIMS[:ndims]\n    if coords is None:\n        coords = get_lookup_coords(*arr.shape)[:ndims]\n    if cnames is None:\n        cnames = cfg.LUT_DIMS_LONGNAMES[:ndims]\n    if cunits is None:\n        cunits = [\"deg\"] * ndims\n\n    # Make xarray-readable (dim, coord) pairs\n    coords_xr = list(zip(dims, coords))\n\n    # Make DataArray\n    da = xr.DataArray(arr, coords=coords_xr, name=name)\n    for i, coord in enumerate(da.coords):\n        da.coords[coord].attrs[\"long_name\"] = cnames[i]\n        da.coords[coord].attrs[\"units\"] = cunits[i]\n    return da\n</code></pre>"},{"location":"reference/helpers/#helpers.pol2cart","title":"<code>pol2cart(rho, phi)</code>","text":"<p>Convert ordered coordinate pairs from polar (r,theta) to Cartesian (X,Y).</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Distance from origin.</p> required <code>phi</code> <code>array</code> <p>Polar angle, [radians].</p> required <p>Returns:</p> Type Description <p>x,y (array): Cartesian coordinates</p> Source code in <code>roughness/helpers.py</code> <pre><code>def pol2cart(rho, phi):\n\"\"\"\n    Convert ordered coordinate pairs from polar (r,theta) to Cartesian (X,Y).\n\n    Parameters:\n        rho (array): Distance from origin.\n        phi (array): Polar angle, [radians].\n\n    Returns:\n        x,y (array): Cartesian coordinates\n    \"\"\"\n    x = rho * np.cos(phi)\n    y = rho * np.sin(phi)\n    return (x, y)\n</code></pre>"},{"location":"reference/helpers/#helpers.rm_regex","title":"<code>rm_regex(dirpath, regex)</code>","text":"<p>Remove all files matching regex in dirpath.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def rm_regex(dirpath, regex):\n\"\"\"Remove all files matching regex in dirpath.\"\"\"\n    dirpath = Path(dirpath)\n    for f in dirpath.rglob(regex):\n        f.unlink()\n</code></pre>"},{"location":"reference/helpers/#helpers.set_data_version","title":"<code>set_data_version(data_version_file=cfg.FDATA_VERSION)</code>","text":"<p>Set data version in data/data_version.txt.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def set_data_version(data_version_file=cfg.FDATA_VERSION):\n\"\"\"Set data version in data/data_version.txt.\"\"\"\n    with open(data_version_file, \"w\", encoding=\"utf8\") as f:\n        f.write(cfg.__version__)\n</code></pre>"},{"location":"reference/helpers/#helpers.spec2xr","title":"<code>spec2xr(arr, wls, units='W/m\u00b2/sr/\u03bcm', wl_units='\u03bcm')</code>","text":"<p>Return spectral numpy array as xarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>array</code> <p>Spectral array.</p> required <code>wls</code> <code>array</code> <p>Wavelength array.</p> required <code>units</code> <code>str</code> <p>Units of spectral array (default: W/m\u00b2/sr/\u03bcm).</p> <code>'W/m\u00b2/sr/\u03bcm'</code> <code>wl_units</code> <code>str</code> <p>Units of wavelength array (default: \u03bcm).</p> <code>'\u03bcm'</code> <p>Returns:</p> Type Description <p>xarray.DataArray</p> Source code in <code>roughness/helpers.py</code> <pre><code>def spec2xr(arr, wls, units=\"W/m\u00b2/sr/\u03bcm\", wl_units=\"\u03bcm\"):\n\"\"\"\n    Return spectral numpy array as xarray.\n\n    Parameters:\n        arr (array): Spectral array.\n        wls (array): Wavelength array.\n        units (str): Units of spectral array (default: W/m\u00b2/sr/\u03bcm).\n        wl_units (str): Units of wavelength array (default: \u03bcm).\n\n    Returns:\n        xarray.DataArray\n    \"\"\"\n    da = xr.DataArray(arr, coords=[wls], dims=[\"wavelength\"], name=\"Radiance\")\n    da.attrs[\"units\"] = units\n    da.coords[\"wavelength\"].attrs[\"long_name\"] = \"Wavelength\"\n    da.coords[\"wavelength\"].attrs[\"units\"] = wl_units\n    return da\n</code></pre>"},{"location":"reference/helpers/#helpers.sph2cart","title":"<code>sph2cart(theta, phi, radius=1)</code>","text":"<p>Convert from spherical (theta, phi, r) to cartesian (x, y, z) coordinates.</p> <p>Theta and phi must be specified in radians and returned units correspond to units of r, default is unitless (r=1 is unit vector). Returns vectors along z-axis (e.g., if theta and phi are int/float return 1x1x3 vector; if theta and phi are MxN arrays return 3D array of vectors MxNx3).</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>num or array</code> <p>Polar angle [rad].</p> required <code>phi</code> <code>num or array</code> <p>Azimuthal angle [rad].</p> required <code>radius</code> <code>num or array</code> <p>Radius (default=1).</p> <code>1</code> <p>Returns:</p> Type Description <code>array</code> <p>Cartesian vector(s), same shape as theta and phi.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def sph2cart(theta, phi, radius=1):\n\"\"\"\n    Convert from spherical (theta, phi, r) to cartesian (x, y, z) coordinates.\n\n    Theta and phi must be specified in radians and returned units correspond to\n    units of r, default is unitless (r=1 is unit vector). Returns vectors along\n    z-axis (e.g., if theta and phi are int/float return 1x1x3 vector; if theta\n    and phi are MxN arrays return 3D array of vectors MxNx3).\n\n    Parameters:\n        theta (num or array): Polar angle [rad].\n        phi (num or array): Azimuthal angle [rad].\n        radius (num or array): Radius (default=1).\n\n    Returns:\n        (array): Cartesian vector(s), same shape as theta and phi.\n    \"\"\"\n    if isinstance(theta, xr.DataArray):\n        theta = theta.values\n    if isinstance(phi, xr.DataArray):\n        phi = phi.values\n    return np.dstack(\n        [\n            radius * np.sin(theta) * np.cos(phi),\n            radius * np.sin(theta) * np.sin(phi),\n            radius * np.cos(theta),\n        ]\n    ).squeeze()\n</code></pre>"},{"location":"reference/helpers/#helpers.sph2cart_xr","title":"<code>sph2cart_xr(theta, phi, radius=1)</code>","text":"<p>Convert spherical to cartesian coordinates using xarray.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>DataArray</code> <p>Polar angle [rad].</p> required <code>phi</code> <code>DataArray</code> <p>Azimuthal angle [rad].</p> required <code>radius</code> <code>num or array</code> <p>Radius (default=1).</p> <code>1</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Cartesian vector(s), same shape as theta and phi.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def sph2cart_xr(theta, phi, radius=1):\n\"\"\"\n    Convert spherical to cartesian coordinates using xarray.\n\n    Parameters:\n        theta (DataArray): Polar angle [rad].\n        phi (DataArray): Azimuthal angle [rad].\n        radius (num or array): Radius (default=1).\n\n    Returns:\n        (DataArray): Cartesian vector(s), same shape as theta and phi.\n    \"\"\"\n    return xr.concat(\n        [\n            radius * np.sin(theta) * np.cos(phi),\n            radius * np.sin(theta) * np.sin(phi),\n            radius * np.cos(theta),\n        ],\n        dim=\"xyz\",\n    )\n</code></pre>"},{"location":"reference/helpers/#helpers.tloc_to_inc","title":"<code>tloc_to_inc(tloc, lat=0, az=False)</code>","text":"<p>Return the solar incidence angle given the local time in hrs.</p> <p>Parameters:</p> Name Type Description Default <code>az</code> <code>bool) Return azimuth angle (default</code> <p>False)</p> <code>False</code> <p>Returns:</p> Type Description <p>inc (float) Solar incidence angle [deg]</p> <p>az (float) Solar azimuth angle (if az=True) [deg]</p> Source code in <code>roughness/helpers.py</code> <pre><code>def tloc_to_inc(tloc, lat=0, az=False):\n\"\"\"\n    Return the solar incidence angle given the local time in hrs.\n\n    Parameters:\n        tloc (float) Local time (0, 24) [hrs]\n        lat (float) Latitude (-90, 90) [deg]\n        az (bool) Return azimuth angle (default: False)\n\n    Returns:\n        inc (float) Solar incidence angle [deg]\n        az (float) Solar azimuth angle (if az=True) [deg]\n    \"\"\"\n    latr = np.deg2rad(lat)\n    hr_angle = np.deg2rad(15 * (12 - tloc))  # (morning is +; afternoon is -)\n    inc = np.rad2deg(np.arccos(np.cos(hr_angle) * np.cos(latr)))\n    if az:\n        az = np.arctan2(np.sin(hr_angle), -np.sin(latr) * np.cos(-hr_angle))\n        az = (np.rad2deg(az) + 360) % 360  # [0, 360) from N\n        return inc, az\n    return inc\n</code></pre>"},{"location":"reference/helpers/#helpers.triple_cross_xr","title":"<code>triple_cross_xr(a, b, c)</code>","text":"<p>Return cross product of a, b, c in 3D Cartesian coordinates.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def triple_cross_xr(a, b, c):\n\"\"\"Return cross product of a, b, c in 3D Cartesian coordinates.\"\"\"\n    return b * a.dot(c, dims=\"xyz\") - c * a.dot(b, dims=\"xyz\")\n</code></pre>"},{"location":"reference/helpers/#helpers.versions_match","title":"<code>versions_match(version_a, version_b, precision=2)</code>","text":"<p>Check if semantic versions match to precision (default 2).</p>"},{"location":"reference/helpers/#helpers.versions_match--examples","title":"Examples","text":"<p>versions_match('1.0.0', '1.2.3', precision=1) True versions_match('1.2.0', '1.2.3', precision=2) True versions_match('1.2.3', '1.2.3', precision=3) True</p> Source code in <code>roughness/helpers.py</code> <pre><code>def versions_match(version_a, version_b, precision=2):\n\"\"\"\n    Check if semantic versions match to precision (default 2).\n\n    Examples\n    --------\n    &gt;&gt;&gt; versions_match('1.0.0', '1.2.3', precision=1)\n    True\n    &gt;&gt;&gt; versions_match('1.2.0', '1.2.3', precision=2)\n    True\n    &gt;&gt;&gt; versions_match('1.2.3', '1.2.3', precision=3)\n    True\n    \"\"\"\n    va_split = version_a.split(\".\")\n    vb_split = version_b.split(\".\")\n    for i in range(precision):\n        if va_split[i] != vb_split[i]:\n            return False\n    return True\n</code></pre>"},{"location":"reference/helpers/#helpers.wl2xr","title":"<code>wl2xr(arr, units='\u03bcm')</code>","text":"<p>Return wavelength numpy array as xarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>array</code> <p>Wavelength array.</p> required <code>units</code> <code>str</code> <p>Units of wavelengths (default: \u03bcm).</p> <code>'\u03bcm'</code> <p>Returns:</p> Type Description <p>xarray.DataArray</p> Source code in <code>roughness/helpers.py</code> <pre><code>def wl2xr(arr, units=\"\u03bcm\"):\n\"\"\"\n    Return wavelength numpy array as xarray.\n\n    Parameters:\n        arr (array): Wavelength array.\n        units (str): Units of wavelengths (default: \u03bcm).\n\n    Returns:\n        xarray.DataArray\n    \"\"\"\n    da = xr.DataArray(arr, coords=[(\"wavelength\", arr)])\n    da.coords[\"wavelength\"].attrs[\"long_name\"] = \"Wavelength\"\n    da.coords[\"wavelength\"].attrs[\"units\"] = units\n    return da\n</code></pre>"},{"location":"reference/helpers/#helpers.wn2xr","title":"<code>wn2xr(arr, units='cm^-1')</code>","text":"<p>Return wavenumber numpy array as xarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>array</code> <p>Wavenumber array.</p> required <code>units</code> <code>str</code> <p>Units of wavenumbers (default: cm^-1).</p> <code>'cm^-1'</code> <p>Returns:</p> Type Description <p>xarray.DataArray</p> Source code in <code>roughness/helpers.py</code> <pre><code>def wn2xr(arr, units=\"cm^-1\"):\n\"\"\"\n    Return wavenumber numpy array as xarray.\n\n    Parameters:\n        arr (array): Wavenumber array.\n        units (str): Units of wavenumbers (default: cm^-1).\n\n    Returns:\n        xarray.DataArray\n    \"\"\"\n    da = xr.DataArray(arr, coords=[(\"wavenumber\", arr)])\n    da.coords[\"wavelength\"].attrs[\"long_name\"] = \"Wavenumber\"\n    da.coords[\"wavelength\"].attrs[\"units\"] = units\n    return da\n</code></pre>"},{"location":"reference/helpers/#helpers.xarr2geotiff","title":"<code>xarr2geotiff(xarr, savefile, crs=cfg.MOON2000_ESRI)</code>","text":"<p>Write xarray image to geotiff with rasterio.</p> <p>xarr can must have dims (wavelength, lat, lon) or (lat, lon).</p> <p>Parameters:</p> Name Type Description Default <code>xarr</code> <code>DataArray</code> <p>Image to save.</p> required <code>savefile</code> <code>str</code> <p>Filename to save to.</p> required <code>crs</code> <code>str</code> <p>Coordinate reference system (default: MOON2000_ESRI).</p> <code>MOON2000_ESRI</code> Source code in <code>roughness/helpers.py</code> <pre><code>def xarr2geotiff(xarr, savefile, crs=cfg.MOON2000_ESRI):\n\"\"\"\n    Write xarray image to geotiff with rasterio.\n\n    xarr can must have dims (wavelength, lat, lon) or (lat, lon).\n\n    Parameters:\n        xarr (xarray.DataArray): Image to save.\n        savefile (str): Filename to save to.\n        crs (str): Coordinate reference system (default: MOON2000_ESRI).\n    \"\"\"\n    xarr = xarr.rio.write_crs(crs)\n    if \"wavelength\" in xarr.dims:\n        xarr = xarr.transpose(\"wavelength\", \"lat\", \"lon\")\n    else:\n        xarr = xarr.transpose(\"lat\", \"lon\")\n    xarr = xarr.rio.set_spatial_dims(\"lon\", \"lat\")\n    xarr.rio.to_raster(savefile)\n    if Path(savefile).exists():\n        print(\"Wrote to\", savefile)\n    else:\n        print(\"Failed to write to\", savefile)\n</code></pre>"},{"location":"reference/helpers/#helpers.xy2lonlat_coords","title":"<code>xy2lonlat_coords(x, y, extent)</code>","text":"<p>Convert x,y coordinates to lat,lon coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x,</code> <code>y (array</code> <p>x,y coordinates.</p> required <code>extent</code> <code>tuple</code> <p>Lon/lat extent (lonmin, lonmax, latmin, latmax).</p> required <p>Returns:</p> Type Description <p>lon, lat (array): Lon/lat coordinates.</p> Source code in <code>roughness/helpers.py</code> <pre><code>def xy2lonlat_coords(x, y, extent):\n\"\"\"\n    Convert x,y coordinates to lat,lon coordinates.\n\n    Parameters:\n        x, y (array): x,y coordinates.\n        extent (tuple): Lon/lat extent (lonmin, lonmax, latmin, latmax).\n\n    Returns:\n        lon, lat (array): Lon/lat coordinates.\n    \"\"\"\n    lon = np.linspace(extent[0], extent[1], len(x))\n    lat = np.linspace(extent[3], extent[2], len(y))\n    return lon, lat\n</code></pre>"},{"location":"reference/m3_correction/","title":"m3_correction","text":"<p>M3-specific functions for testing</p>"},{"location":"reference/m3_correction/#m3_correction.assign_loc","title":"<code>assign_loc(da, basename, usgs=2)</code>","text":"<p>Return da with loc backplane assigned as 2D coords of (x, y).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def assign_loc(da, basename, usgs=2):\n\"\"\"Return da with loc backplane assigned as 2D coords of (x, y).\"\"\"\n    loc = get_m3xr(basename, \"loc\", usgs, dask=False, xoak=False)\n    da = da.assign_coords(\n        {\n            \"lat\": ((\"y\", \"x\"), loc.sel(band=2).data),\n            \"lon\": ((\"y\", \"x\"), loc.sel(band=1).data),\n        }\n    )\n    da.attrs[\"floc\"] = loc.attrs[\"fimg\"]\n    return da\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.bands2wls","title":"<code>bands2wls(da, basename)</code>","text":"<p>Return da with M3 wavelength coordinate replacing bands.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def bands2wls(da, basename):\n\"\"\"Return da with M3 wavelength coordinate replacing bands.\"\"\"\n    wls = get_m3_wls(basename)\n    da = (\n        da.assign_coords(wavelength=(\"band\", wls))\n        .swap_dims({\"band\": \"wavelength\"})\n        .drop(\"band\")\n    )\n    return da\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.contin_remove","title":"<code>contin_remove(spec, wl1=2.537, wl2=2.657, divide=True)</code>","text":"<p>Remove linear continuum fit between wl1 and wl2 from spec.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def contin_remove(spec, wl1=2.537, wl2=2.657, divide=True):\n\"\"\"Remove linear continuum fit between wl1 and wl2 from spec.\"\"\"\n    slope, intercept = lin_contin(spec, wl1, wl2)\n    contin = slope * spec.wavelength + intercept\n    if divide:\n        return spec / contin\n    return spec - contin\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.emission_xr_helper","title":"<code>emission_xr_helper(ind, args, kwargs)</code>","text":"<p>Helper function for emission_xr.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def emission_xr_helper(ind, args, kwargs):\n\"\"\"Helper function for emission_xr.\"\"\"\n    # ind is (wls, x, y), drop wls dim and slice other args by (x, y)\n    # ind = tupl[i for i in ind if not (i.start == 0 and i.stop == len(args[4]))]\n    args = [a[ind] if i &lt; 5 else a for i, a in enumerate(args)]\n    # kwargs = [k[ind] if isinstance(k, xr.DataArray) else k for k in kwargs]\n    return get_emission_xr(*args, **kwargs)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.ext2window","title":"<code>ext2window(ext, transform)</code>","text":"<p>Return rasterio window of data bounded by ext in dataset with transform.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def ext2window(ext, transform):\n\"\"\"Return rasterio window of data bounded by ext in dataset with transform.\"\"\"\n    # Location of upper left corner of data (pixel offset)\n    row_off, col_off = rio.transform.rowcol(transform, ext[0], ext[3])\n    # Size of window (in pixels)\n    xres = transform[0]\n    yres = -transform[4]\n    width = int(round((ext[1] - ext[0]) / xres))\n    height = int(round((ext[3] - ext[2]) / yres))\n    w = rio.windows.Window(col_off, row_off, width, height)\n    return w\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.furnsh_kernels","title":"<code>furnsh_kernels(kernels_path=KERNELPATH)</code>","text":"<p>Return spiceypy kernels for meta_path.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def furnsh_kernels(kernels_path=KERNELPATH):\n\"\"\"\n    Return spiceypy kernels for meta_path.\n    \"\"\"\n    kernels = Path(kernels_path)\n    if kernels.suffix != \".tm\":\n        # Get all kernels, exlude meta kernels ('.tm')\n        kernels = [\n            k.as_posix() for k in kernels.rglob(\"*\") if k.suffix != \".tm\"\n        ]\n    spiceypy.furnsh(kernels)  # Else assume path is a .tm\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_albedo_feng","title":"<code>get_albedo_feng(lons, lats)</code>","text":"<p>Return albedo interpolated from Feng et al. (2020) at lons, lats.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_albedo_feng(lons, lats):\n\"\"\"Return albedo interpolated from Feng et al. (2020) at lons, lats.\"\"\"\n    return read_albedo_map_feng().interp(lon=lon180(lons), lat=lats)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_avg_spec","title":"<code>get_avg_spec(img, wlmin=0, wlmax=100000.0, wls=None)</code>","text":"<p>Return the wavelengths and mean spectrum within the specified img array. Optionally specify min and max wavelengths to crop spectrum.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_avg_spec(img, wlmin=0, wlmax=1e5, wls=None):\n\"\"\"Return the wavelengths and mean spectrum within the specified img array.\n    Optionally specify min and max wavelengths to crop spectrum.\"\"\"\n    if isinstance(img, xr.DataArray):  # Average along wavelength dimension\n        try:\n            arr = img.mean([\"x\", \"y\"])\n        except ValueError:\n            arr = img.mean([\"lon\", \"lat\"])\n    else:\n        arr = np.nanmean(img, axis=(0, 1))  # Average along z (spectral) axis\n    return get_spec(arr, wlmin, wlmax, wls)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_avg_sun_inc_az","title":"<code>get_avg_sun_inc_az(obs, dem=None)</code>","text":"<p>Return average solar incidence and azimuth from obs file.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_avg_sun_inc_az(obs, dem=None):\n\"\"\"\n    Return average solar incidence and azimuth from obs file.\n    \"\"\"\n    sun_thetas, sun_azs, *_ = get_m3_geom(obs, dem)\n    return np.mean(sun_thetas), np.mean(sun_azs)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_dem_geotiff","title":"<code>get_dem_geotiff(fslo, fazim, felev, ext, width=None, height=None, resampling='nearest')</code>","text":"<p>Return DEM geotiff from fslo, fazim, felev geotiff files.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_dem_geotiff(\n    fslo, fazim, felev, ext, width=None, height=None, resampling=\"nearest\"\n):\n\"\"\"\n    Return DEM geotiff from fslo, fazim, felev geotiff files.\n    \"\"\"\n    left, right, bot, top = ext\n    rs = getattr(rio.enums.Resampling, resampling)\n    with rio.open(fslo) as s, rio.open(fazim) as a, rio.open(felev) as e:\n        w = rio.windows.from_bounds(left, bot, right, top, s.transform)\n        if width is None:\n            width = int(w.width)\n        if height is None:\n            height = int(w.height)\n        outshape = (1, height, width)\n        slo = s.read(window=w, out_shape=outshape, resampling=rs)\n        azim = a.read(window=w, out_shape=outshape, resampling=rs)\n        elev = e.read(window=w, out_shape=outshape, resampling=rs)\n    dem = rio2xy(np.vstack([slo, azim, elev]))\n    return dem\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_dem_xr","title":"<code>get_dem_xr(fslope, fazimuth, felevation)</code>","text":"<p>Return DEM as xarray from fslope, fazimuth, felevation</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_dem_xr(fslope, fazimuth, felevation):\n\"\"\"Return DEM as xarray from fslope, fazimuth, felevation\"\"\"\n    s = xr.open_dataarray(fslope).sel(band=1).drop(\"band\")\n    a = xr.open_dataarray(fazimuth).sel(band=1).drop(\"band\")\n    e = xr.open_dataarray(felevation).sel(band=1).drop(\"band\")\n    s.name = \"Slope (rad)\"\n    a.name = \"Aspect (rad)\"\n    e.name = \"Elevation\"\n    dem = xr.Dataset({\"slope\": s, \"aspect\": a, \"elevation\": e})\n    dem = dem.rename({\"x\": \"lon\", \"y\": \"lat\"})\n    return dem\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_emission_xr","title":"<code>get_emission_xr(inc, iaz, em, eaz, alb, wls, tloc, ls, lat=None, **kwargs)</code>","text":"<p>Return emission [W/(m^2 um)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_emission_xr(inc, iaz, em, eaz, alb, wls, tloc, ls, lat=None, **kwargs):\n\"\"\"Return emission [W/(m^2 um)].\"\"\"\n    emission = xr.zeros_like(inc * wls)\n    dorig = emission.dims\n    dim0, dim1 = [dim for dim in inc.dims if dim != \"band\"]\n    emission = emission.transpose(dim0, dim1, \"wavelength\")\n    for j in range(len(emission[dim0])):\n        for k in range(len(emission[dim1])):\n            ind = {dim0: j, dim1: k}\n            geom = [da.isel(ind).values for da in [inc, iaz, em, eaz]]\n            if any([np.isnan(v) for v in geom]):\n                continue\n            albedo = alb.isel(ind).values\n            if lat is None:\n                lat = inc.isel(ind).lat.values\n            tparams = {\"tloc\": tloc, \"albedo\": albedo, \"lat\": lat, \"ls\": ls}\n\n            emission[j, k] = re.rough_emission_lookup(\n                geom, wls, tparams=tparams, **kwargs\n            )\n        print(j, end=\" \")\n    # Transpose back to original axis order\n    emission = emission.transpose(*dorig)\n    return emission\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_ls_spice","title":"<code>get_ls_spice(basename)</code>","text":"<p>Return solar longitude (L_s) from basename.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_ls_spice(basename):\n\"\"\"Return solar longitude (L_s) from basename.\"\"\"\n    utc = m3basename2utc(basename)\n    return utc2lsmoon(utc)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_date","title":"<code>get_m3_date(basename)</code>","text":"<p>Return date object representing date of M3 observation</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_date(basename):\n\"\"\"Return date object representing date of M3 observation\"\"\"\n    return datetime.strptime(basename[3:].replace(\"T\", \"\"), \"%Y%m%d%H%M%S\")\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_directory","title":"<code>get_m3_directory(basename, dirpath='', level='L2')</code>","text":"<p>Return PDS-like path to M3 observation, given basename and dirpath to m3 root directory.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_directory(basename, dirpath=\"\", level=\"L2\"):\n\"\"\"\n    Return PDS-like path to M3 observation, given basename and dirpath to m3\n    root directory.\n    \"\"\"\n    # Build M3 data path as list, join at the end\n    m3dir = Path(dirpath)\n\n    if level == \"L1B\":\n        m3dir = m3dir / \"CH1M3_0003\"\n    elif level == \"L2\":\n        m3dir = m3dir / \"CH1M3_0004\"\n    m3dir = m3dir / \"DATA\"\n\n    # Get optical period\n    opt = get_m3_op(basename)\n    if opt[2] == \"1\":\n        m3dir = m3dir / \"20081118_20090214\"\n    elif opt[2] == \"2\":\n        m3dir = m3dir / \"20090415_20090816\"\n\n    m3dir = m3dir / basename[3:9] / level\n    return m3dir\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_geom","title":"<code>get_m3_geom(obs, dem=None)</code>","text":"<p>Return geometry array from M3 observation file and optional dem.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_geom(obs, dem=None):\n\"\"\"Return geometry array from M3 observation file and optional dem.\"\"\"\n    if dem is None:\n        dem_theta = np.radians(obs[:, :, 7])\n        dem_az = np.radians(obs[:, :, 8])\n    else:\n        dem_theta = np.arctan(dem[:, :, 0])\n        dem_az = dem[:, :, 1]\n    sun_az = np.radians(obs[:, :, 0])\n    sun_theta = np.radians(obs[:, :, 1])\n    sc_az = np.radians(obs[:, :, 2])\n    sc_theta = np.radians(obs[:, :, 3])\n\n    # Compute angles in degrees\n    i, e, g, _ = rh.get_ieg(\n        dem_theta, dem_az, sun_theta, sun_az, sc_theta, sc_az\n    )\n    sun_az = np.rad2deg(sun_az)\n    sc_az = np.rad2deg(sc_az)\n    return i, sun_az, e, sc_az, g\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_geom_xr","title":"<code>get_m3_geom_xr(obs, dem=None)</code>","text":"<p>Return geometry from M3 observation file and optional dem as xarray.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_geom_xr(obs, dem=None):\n\"\"\"Return geometry from M3 observation file and optional dem as xarray.\"\"\"\n    sun_az = obs.sel(band=1)  # To-sun azimuth [deg]\n    sun_z = obs.sel(band=2)  # To-sun zenith [deg]\n    sc_az = obs.sel(band=3)  # To-spacecraft azimuth [deg]\n    sc_z = obs.sel(band=4)  # To-spacecraft zenith [deg]\n    if dem is None:\n        # Pull cos(i) relative to dem and phase from obs\n        i = np.rad2deg(np.arccos(obs.sel(band=10)))  # Incidence [deg]\n        g = obs.sel(band=5)  # Phase [deg]\n\n        # Compute e relative to dem\n        dem_sl = obs.sel(band=8)  # Facet slope [deg]\n        dem_az = obs.sel(band=9)  # Facet azimuth [deg]\n        dem_cart = rh.sph2cart_xr(np.deg2rad(dem_sl), np.deg2rad(dem_az))\n        sc_cart = rh.sph2cart_xr(np.deg2rad(sc_z), np.deg2rad(sc_az))\n        e = rh.get_angle_between_xr(dem_cart, sc_cart, True)\n    else:\n        # Compute i,e,g relative to dem\n        dem_sl = np.arctan(dem.slope)  # [radians]\n        dem_az = dem.aspect  # [radians]\n        args = [np.deg2rad(a) for a in [sun_z, sun_az, sc_z, sc_az]]\n        i, e, g, _ = rh.get_ieg_xr(dem_sl, dem_az, *args)\n    return i, sun_az, e, sc_az, g\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_headers","title":"<code>get_m3_headers(basename, dirpath=M3PATH, flatdir=False, imgs=('rad', 'ref', 'obs', 'sup', 'loc'), usgs=0, usgspath='', ext='.HDR')</code>","text":"<p>Return dict of paths to M3 header files for an observation.</p>"},{"location":"reference/m3_correction/#m3_correction.get_m3_headers--see-also","title":"See Also","text":"<p>https://astrogeology.usgs.gov/maps/         moon-mineralogy-mapper-geometric-data-restoration</p>"},{"location":"reference/m3_correction/#m3_correction.get_m3_headers--examples","title":"Examples","text":"<p>get_m3_headers(\"M3G20090609T183254\", dirpath=\"/path/to/m3\") {'rad': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/          M3G20090609T183254_V03_RDN.HDR', 'ref': '/path/to/m3/CH1M3_0004/DATA/20090415_20090816/200906/L2/         M3G20090609T183254_V01_RFL.HDR', 'obs': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/         M3G20090609T183254_V03_OBS.HDR', 'sup': '/path/to/m3/CH1M3_0004/DATA/20090415_20090816/200906/L2/         M3G20090609T183254_V01_SUP.HDR', 'loc': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/         M3G20090609T183254_V03_LOC.HDR'} get_m3_headers(\"M3G20090609T183254\", dirpath=\"/path/to/imgs\",                    flatdir=True) {'rad': '/path/to/imgs/M3G20090609T183254_V03_RDN.HDR', 'ref': '/path/to/imgs/M3G20090609T183254_V01_RFL.HDR', 'obs': '/path/to/imgs/M3G20090609T183254_V03_OBS.HDR', 'sup': '/path/to/imgs/M3G20090609T183254_V01_SUP.HDR', 'loc': '/path/to/imgs/M3G20090609T183254_V03_LOC.HDR'} get_m3_headers(\"M3G20090609T183254\", dirpath=\"m3path\", usgs=1,                     usgspath=\"usgspath\") {'rad': 'm3path/CH1M3_0003/DATA/20090415_20090816/200906/L1B/          M3G20090609T183254_V03_RDN.HDR', 'ref': 'm3path/CH1M3_0004/DATA/20090415_20090816/200906/L2/         M3G20090609T183254_V01_RFL.HDR', 'obs': 'usgspath/boardman2014/M3G20090609T183254_V03_OBS.HDR', 'sup': 'm3path/CH1M3_0004/DATA/20090415_20090816/200906/L2/         M3G20090609T183254_V01_SUP.HDR', 'loc': 'usgspath/boardman2014/M3G20090609T183254_V03_LOC.HDR'}</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_headers(\n    basename,\n    dirpath=M3PATH,\n    flatdir=False,\n    imgs=(\"rad\", \"ref\", \"obs\", \"sup\", \"loc\"),\n    usgs=0,\n    usgspath=\"\",\n    ext=\".HDR\",\n):\n\"\"\"\n    Return dict of paths to M3 header files for an observation.\n\n    See Also\n    --------\n    https://astrogeology.usgs.gov/maps/\n            moon-mineralogy-mapper-geometric-data-restoration\n\n    Examples\n    --------\n    &gt;&gt;&gt; get_m3_headers(\"M3G20090609T183254\", dirpath=\"/path/to/m3\")\n    {'rad': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/\n             M3G20090609T183254_V03_RDN.HDR',\n    'ref': '/path/to/m3/CH1M3_0004/DATA/20090415_20090816/200906/L2/\n            M3G20090609T183254_V01_RFL.HDR',\n    'obs': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/\n            M3G20090609T183254_V03_OBS.HDR',\n    'sup': '/path/to/m3/CH1M3_0004/DATA/20090415_20090816/200906/L2/\n            M3G20090609T183254_V01_SUP.HDR',\n    'loc': '/path/to/m3/CH1M3_0003/DATA/20090415_20090816/200906/L1B/\n            M3G20090609T183254_V03_LOC.HDR'}\n    &gt;&gt;&gt; get_m3_headers(\"M3G20090609T183254\", dirpath=\"/path/to/imgs\",\n                       flatdir=True)\n    {'rad': '/path/to/imgs/M3G20090609T183254_V03_RDN.HDR',\n    'ref': '/path/to/imgs/M3G20090609T183254_V01_RFL.HDR',\n    'obs': '/path/to/imgs/M3G20090609T183254_V03_OBS.HDR',\n    'sup': '/path/to/imgs/M3G20090609T183254_V01_SUP.HDR',\n    'loc': '/path/to/imgs/M3G20090609T183254_V03_LOC.HDR'}\n    &gt;&gt;&gt; get_m3_headers(\"M3G20090609T183254\", dirpath=\"m3path\", usgs=1,\n                        usgspath=\"usgspath\")\n    {'rad': 'm3path/CH1M3_0003/DATA/20090415_20090816/200906/L1B/\n             M3G20090609T183254_V03_RDN.HDR',\n    'ref': 'm3path/CH1M3_0004/DATA/20090415_20090816/200906/L2/\n            M3G20090609T183254_V01_RFL.HDR',\n    'obs': 'usgspath/boardman2014/M3G20090609T183254_V03_OBS.HDR',\n    'sup': 'm3path/CH1M3_0004/DATA/20090415_20090816/200906/L2/\n            M3G20090609T183254_V01_SUP.HDR',\n    'loc': 'usgspath/boardman2014/M3G20090609T183254_V03_LOC.HDR'}\n    \"\"\"\n    single_img = False\n    if isinstance(imgs, str):\n        single_img = True\n        imgs = [imgs]\n\n    img2name = {\n        \"rad\": \"RDN\",\n        \"ref\": \"RFL\",\n        \"obs\": \"OBS\",\n        \"sup\": \"SUP\",\n        \"loc\": \"LOC\",\n        \"lbl\": \"L1B\",\n    }\n\n    if flatdir:\n        # All images in toplevel directory at dirpath\n        l1b = dirpath\n        l2 = dirpath\n    else:\n        # Full m3 volume located at dirpath\n        l1b = get_m3_directory(basename, dirpath, \"L1B\")\n        l2 = get_m3_directory(basename, dirpath, \"L2\")\n\n    # Get full path for each img\n    headers = {}\n    for img in imgs:\n        _ext = ext\n        if img in (\"rad\", \"loc\", \"obs\", \"lbl\"):\n            version = \"V03\"\n            level = l1b\n            if img == \"lbl\":\n                _ext = \".LBL\"\n        elif img in (\"ref\", \"sup\"):\n            version = \"V01\"\n            level = l2\n        else:\n            raise ValueError(f\"Unknown image type: {img}\")\n        fname = \"_\".join((basename, version, img2name[img] + _ext))\n        headers[img] = Path(level) / fname\n\n    # USGS corrected loc and obs\n    if usgs:\n        if not usgspath:\n            usgspath = Path(dirpath) / \"USGS\"\n        if usgs == 1:\n            # Step 1 usgs correction (2014)\n            usgsdir = \"boardman2014\"\n            loc = basename + \"_V03_LOC.HDR\"\n            obs = basename + \"_V03_OBS.HDR\"\n        elif usgs == 2:\n            # Step 2 usgs correction (2017)\n            usgsdir = \"boardman2017\"\n            loc = basename + \"_V03_L1B_LOC_USGS.hdr\"\n            obs = basename + \"_V03_L1B_OBS.HDR\"\n        else:\n            raise ValueError(\"Invalid usgs step (must be 1 or 2)\")\n        headers[\"loc\"] = Path(usgspath) / usgsdir / loc\n        headers[\"obs\"] = Path(usgspath) / usgsdir / obs\n    if single_img:\n        headers = headers[imgs[0]]\n    return headers\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_op","title":"<code>get_m3_op(basename)</code>","text":"<p>Return optical period of m3 observation based on date of observation</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_op(basename):\n\"\"\"Return optical period of m3 observation based on date of observation\"\"\"\n\n    def date_in_range(date, start, end):\n        start = datetime.strptime(start, \"%Y%m%d\")\n        end = datetime.strptime(end, \"%Y%m%d\")\n        return start &lt;= date &lt; end\n\n    date = get_m3_date(basename)\n    if date_in_range(date, \"20081118\", \"20090125\"):\n        opt = \"OP1A\"\n    elif date_in_range(date, \"20090125\", \"20090215\"):\n        opt = \"OP1B\"\n    elif date_in_range(date, \"20090415\", \"20090428\"):\n        opt = \"OP2A\"\n    elif date_in_range(date, \"20090513\", \"20090517\"):\n        opt = \"OP2B\"\n    elif date_in_range(date, \"20090520\", \"20090623\"):\n        opt = \"OP2C1\"\n    elif date_in_range(date, \"20090623\", \"20090722\"):\n        opt = \"OP2C2\"\n    elif date_in_range(date, \"20090722\", \"20090817\"):\n        opt = \"OP2C3\"\n    else:\n        msg = f\"Optical period for {basename} not found. Check img name.\"\n        raise ValueError(msg)\n    return opt\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_res","title":"<code>get_m3_res(basename)</code>","text":"<p>Return the M3 spatial resolution in m/pixel which depends on the operational mode (Global or Target) and the spacecraft altitude (doubled in OP2C).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_res(basename):\n\"\"\"\n    Return the M3 spatial resolution in m/pixel which depends on the\n    operational mode (Global or Target) and the spacecraft altitude (doubled\n    in OP2C).\n    \"\"\"\n    mode = basename[2]\n    if mode == \"G\":\n        res = 140  # m/pixel\n    elif mode == \"T\":\n        res = 70  # m/pixel\n    else:\n        raise ValueError(\"Basename must begin with M3G or M3T.\")\n    if get_m3_op(basename) in (\"OP2C1\", \"OP2C2\", \"OP2C3\"):\n        res *= 2\n    return res\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_tloc","title":"<code>get_m3_tloc(obs, dem=None, lat=0)</code>","text":"<p>Return average local time of M3 observation.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_tloc(obs, dem=None, lat=0):\n\"\"\"\n    Return average local time of M3 observation.\n    \"\"\"\n    return rh.inc_to_tloc(*get_avg_sun_inc_az(obs, dem), lat)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_warm","title":"<code>get_m3_warm(basename)</code>","text":"<p>Return True if m3 observation was warm (Besse et al., 2013).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_warm(basename):\n\"\"\"Return True if m3 observation was warm (Besse et al., 2013).\"\"\"\n    return get_m3_op(basename) in (\"OP1A\", \"OP2B\", \"OP2C1\", \"OP2C2\")\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3_wls","title":"<code>get_m3_wls(img)</code>","text":"<p>Return wavelength array for an M3 image [microns].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3_wls(img):\n\"\"\"\n    Return wavelength array for an M3 image [microns].\n    \"\"\"\n    if is_targeted(img):\n        wls = TWL\n    else:\n        wls = GWL\n    return np.array(wls) / 1000  # [nm] -&gt; [microns]\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3albedo","title":"<code>get_m3albedo(rad, obs, i, e, g, basename, wlmin=0.55, wlmax=2, amax=0.4)</code>","text":"<p>Return albedo (Bandfield et al. 2018)</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3albedo(rad, obs, i, e, g, basename, wlmin=0.55, wlmax=2, amax=0.4):\n\"\"\"\n    Return albedo (Bandfield et al. 2018)\n    \"\"\"\n    # Add factor to change M3 derived albedo to thermal albedo - JB\n    factor = 2 - np.cos(np.deg2rad(i))\n\n    # Get solar irradiance\n    L_sun = get_solar_irradiance_xr(basename, obs)\n    photom = get_m3photom(i, e, g, basename)\n    refl = re.get_rad_factor(rad, L_sun) * photom\n\n    # Clip noisy M3 channels\n    if isinstance(refl, xr.DataArray):\n        refl = refl.sel(wavelength=slice(wlmin, wlmax))\n        L_sun = L_sun.sel(wavelength=slice(wlmin, wlmax))\n        albedo = (refl * L_sun).sum(\"wavelength\") / L_sun.sum(\"wavelength\")\n    # refl = refl[:, :, bmin:]\n    # L_sun = L_sun[:, :, bmin:]\n    # albedo = np.sum(refl * L_sun, axis=2) / np.sum(L_sun, axis=2)\n    albedo = albedo * factor\n    albedo.clip(max=amax)  # limit exteme albedos\n    return albedo\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3photom","title":"<code>get_m3photom(i, e, g, basename, newph=True, polish=False)</code>","text":"<p>Return photometric correction factor, used to correct M3 radiance to i=30, e=0, g=30 using the M3 photometric correction.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3photom(i, e, g, basename, newph=True, polish=False):\n\"\"\"\n    Return photometric correction factor, used to correct M3 radiance to\n    i=30, e=0, g=30 using the M3 photometric correction.\n    \"\"\"\n    # Limb darkening breaks down at high inc / em angle (Besse et al., 2013)\n    # if i &gt; 85 or e &gt; 85:\n    #     return np.ones_like(g) * np.nan\n\n    # Get M3 photometry table interpolated to phase values\n    targeted = is_targeted(basename)\n    if isinstance(g, xr.DataArray):\n        photom = get_photom_xr(targeted, newph)\n        photom30 = photom.sel(phase=30)\n        photom_g = photom.interp(phase=g)\n    else:\n        phase, photom = get_photom(targeted, newph)\n        photom30 = photom[np.argmin(np.abs(phase - 30))]\n        photom_g = np.interp(g, phase[:, 0], photom[:, 0])\n    norm_photom = photom30 / photom_g\n\n    # limb darkening Lommel-Selliger (Eq. 3, Besse et al., 2013)\n    i, e = np.radians(i), np.radians(e)\n    ld = np.cos(i) / (np.cos(i) + np.cos(e))\n    ld30 = np.cos(np.pi / 6) / (np.cos(np.pi / 6) + np.cos(0))  # i=30, e=0\n    norm_ld = ld30 / ld\n\n    # Get M3 spectral polish\n    if polish:\n        iswarm = get_m3_warm(basename)\n        spec_polish = get_polish(targeted, iswarm)\n    else:\n        spec_polish = 1\n\n    photom_corr = norm_ld * norm_photom * spec_polish  # * np.pi\n    return photom_corr\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_m3xr","title":"<code>get_m3xr(basename, img, usgs=2, dask=False, chunks=None, xoak=False)</code>","text":"<p>Return m3 img (rad/ref/obs/sup/loc) as lazy loaded xarray.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_m3xr(basename, img, usgs=2, dask=False, chunks=None, xoak=False):\n\"\"\"\n    Return m3 img (rad/ref/obs/sup/loc) as lazy loaded xarray.\n    \"\"\"\n    hdr = get_m3_headers(basename, imgs=img, usgs=usgs)\n    fimg = Path(hdr).with_suffix(\".IMG\")\n    if not fimg.exists():\n        fimg = Path(hdr).with_suffix(\".img\")\n    if dask and chunks is None:\n        # Chunk along y (lines), never bands (efficient spectral operations)\n        # x (samples) usually 304 or 608 so chunking along x unnecessary\n        chunks = {\"band\": None, \"y\": \"auto\", \"x\": None}\n    chunks = None\n    da = xr.open_dataarray(\n        fimg,\n        engine=\"rasterio\",\n        parse_coordinates=True,\n        chunks=chunks,\n        drop_variables=[\"spatial_ref\"],\n        default_name=img,\n    )\n\n    if img in (\"rad\", \"ref\"):\n        da = bands2wls(da, basename)\n\n    # Not all attrs useful, some don't parse well from envi header\n    da.attrs = {k: v for k, v in da.attrs.items() if k not in DROP_ATTRS}\n    da.attrs[\"basename\"] = basename\n    da.attrs[\"fimg\"] = fimg.as_posix()\n\n    # Set up lat / lon coords from loc backplane (if loc this is redundant)\n    if img == \"loc\":\n        return da\n    da = assign_loc(da, basename, usgs)\n\n    if xoak:\n        da = index_m3xoak(da)\n    return da\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_photom","title":"<code>get_photom(targeted, newph=True, m3ancpath=M3ANCPATH, m3apt=M3ALTPHOTOM)</code>  <code>cached</code>","text":"<p>Return solar spectrum and alpha photometry tables as arrays.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>@lru_cache(maxsize=3)\ndef get_photom(targeted, newph=True, m3ancpath=M3ANCPATH, m3apt=M3ALTPHOTOM):\n\"\"\"\n    Return solar spectrum and alpha photometry tables as arrays.\n    \"\"\"\n    if targeted:\n        fphotom = Path(m3apt) / \"M3T20120120_RFL_F_ALPHA_HIL.TAB\"\n    elif newph:\n        # Newer photometric correction fixes 2.5-3 micron photometry (default)\n        fphotom = Path(m3apt) / \"M3G20120120_RFL_F_ALPHA_HIL.TAB\"\n    else:\n        # Old photometric correction (artifacts &gt; 2.5 microns)\n        fphotom = Path(m3ancpath) / \"M3G20111109_RFL_F_ALPHA_HIL.TAB\"\n\n    photom = np.genfromtxt(fphotom, skip_header=1)[:, np.newaxis, :]\n    phase = photom[:, :, 0].astype(int)\n    photom = photom[:, :, 1:]\n    return phase, photom\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_photom_xr","title":"<code>get_photom_xr(targeted, *args, **kwargs)</code>","text":"<p>Return xarray m3 photom</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_photom_xr(targeted, *args, **kwargs):\n\"\"\"Return xarray m3 photom\"\"\"\n    phase, photom = get_photom(targeted, *args, **kwargs)\n    photom = xr.DataArray(\n        photom.squeeze(),\n        coords=[\n            (\"phase\", phase.squeeze()),\n            (\"wavelength\", get_m3_wls(targeted)),\n        ],\n    )\n    return photom\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_polish","title":"<code>get_polish(targeted, iswarm=False, m3ancpath=M3ANCPATH)</code>  <code>cached</code>","text":"<p>Return polish based on whether the detector was warm or cold.</p>"},{"location":"reference/m3_correction/#m3_correction.get_polish--returns","title":"Returns","text":"<p>polish_arr (np 1x1xN array)</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>@lru_cache(maxsize=4)\ndef get_polish(targeted, iswarm=False, m3ancpath=M3ANCPATH):\n\"\"\"\n    Return polish based on whether the detector was warm or cold.\n\n    Returns\n    -------\n    polish_arr (np 1x1xN array)\n    \"\"\"\n    if iswarm and targeted:\n        fp = Path(m3ancpath) / \"targeted\" / \"M3T20111020_RFL_STAT_POL_2.TAB\"\n    elif iswarm and not targeted:\n        fp = Path(m3ancpath) / \"M3G20110830_RFL_STAT_POL_2.TAB\"\n    elif not iswarm and targeted:\n        fp = Path(m3ancpath) / \"targeted\" / \"M3T20111020_RFL_STAT_POL_1.TAB\"\n    elif not iswarm and not targeted:\n        fp = Path(m3ancpath) / \"M3G20110830_RFL_STAT_POL_1.TAB\"\n    polish_table = np.loadtxt(fp)\n    polish_arr = polish_table[:, 2].reshape(1, 1, len(polish_table))\n    return polish_arr\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_polish_xr","title":"<code>get_polish_xr(targeted, *args, **kwargs)</code>","text":"<p>Return xarray polish</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_polish_xr(targeted, *args, **kwargs):\n\"\"\"Return xarray polish\"\"\"\n    polish = get_polish(targeted, *args, **kwargs).squeeze()\n    polish = xr.DataArray(\n        polish,\n        coords=[(\"wavelength\", get_m3_wls(targeted))],\n    )\n    return polish\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_solar_dist","title":"<code>get_solar_dist(basename, obs=None)</code>","text":"<p>Get the solar distance subtracted off of M3 obs band 6.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_solar_dist(basename, obs=None):\n\"\"\"\n    Get the solar distance subtracted off of M3 obs band 6.\n    \"\"\"\n    obs_header = get_m3_headers(basename, imgs=\"obs\")\n    if obs is None:\n        obs = float(read_m3_image(obs_header.as_posix(), 0, 1, 0, 1)[:, :, 5])\n    sdist = 1\n    try:\n        params = parse_envi_header(obs_header)\n        description = \"\".join(params[\"description\"])\n        i = description.find(\"(au)\")\n        sdist = float(description[i + 6 : i + 16])\n    except FileNotFoundError as e:\n        w = f\"Could not get sdist for {obs_header}: {str(e)}\"\n        print(w)\n    if isinstance(obs, xr.DataArray):\n        solar_dist = obs.sel(band=6).drop(\"band\") + sdist\n    elif isinstance(obs, np.ndarray):\n        solar_dist = obs[:, :, 5] + sdist\n    else:\n        solar_dist = obs + sdist\n    return solar_dist\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_solar_irradiance_xr","title":"<code>get_solar_irradiance_xr(basename, obs)</code>","text":"<p>Return m3 solar spectrum normalized by solar distance [W/(m^2 um)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_solar_irradiance_xr(basename, obs):\n\"\"\"Return m3 solar spectrum normalized by solar distance [W/(m^2 um)].\"\"\"\n    solar_dist = get_solar_dist(basename, obs)\n    solar_spec = get_solar_spectrum_xr(basename)\n    L_sun = re.get_solar_irradiance(solar_spec, solar_dist)\n    return L_sun\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_solar_spectrum","title":"<code>get_solar_spectrum(targeted=False, m3ancpath=M3ANCPATH)</code>  <code>cached</code>","text":"<p>Return m3 solar spectrum [W/(m^2 um)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>@lru_cache(2)\ndef get_solar_spectrum(targeted=False, m3ancpath=M3ANCPATH):\n\"\"\"Return m3 solar spectrum [W/(m^2 um)].\"\"\"\n    if targeted:\n        fss = Path(m3ancpath) / \"targeted\" / \"M3T20110224_RFL_SOLAR_SPEC.TAB\"\n    else:\n        fss = Path(m3ancpath) / \"M3G20110224_RFL_SOLAR_SPEC.TAB\"\n    ss_raw = np.genfromtxt(fss).T[:, :, np.newaxis]\n    ss = np.moveaxis(ss_raw[1:2], 1, 2)\n    return ss\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_solar_spectrum_xr","title":"<code>get_solar_spectrum_xr(basename, m3ancpath=M3ANCPATH)</code>","text":"<p>Return m3 solar spectrum [W/(m^2 um)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_solar_spectrum_xr(basename, m3ancpath=M3ANCPATH):\n\"\"\"Return m3 solar spectrum [W/(m^2 um)].\"\"\"\n    ss = xr.DataArray(\n        get_solar_spectrum(is_targeted(basename), m3ancpath).squeeze(),\n        coords=[(\"wavelength\", get_m3_wls(basename))],\n    )\n    return ss\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_spec","title":"<code>get_spec(arr, wlmin=0, wlmax=100000.0, wls=None)</code>","text":"<p>Return the wavelengths and spectrum of a 1D arr (1 pixel) of M3 data Optionally specify min and max wavelengths to crop spectrum</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_spec(arr, wlmin=0, wlmax=1e5, wls=None):\n\"\"\"Return the wavelengths and spectrum of a 1D arr (1 pixel) of M3 data\n    Optionally specify min and max wavelengths to crop spectrum\"\"\"\n    if wls is None:\n        wls = get_m3_wls(arr)\n    bmin, wlmin = wl_to_ind(wlmin, wls)\n    bmax, wlmax = wl_to_ind(wlmax, wls)\n    wls = wls[bmin : bmax + 1]\n    spec = arr[bmin : bmax + 1]\n    return wls, spec\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.get_tloc_range_spice","title":"<code>get_tloc_range_spice(basename, minlon, maxlon=None)</code>","text":"<p>Return M3 min and max local time using spice. Gets start and end times from label file if found, else takes timestamp from the basename. In future could read actual times from TIM files (but range usually &lt;0.1 lst for a given image).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def get_tloc_range_spice(basename, minlon, maxlon=None):\n\"\"\"\n    Return M3 min and max local time using spice.\n    Gets start and end times from label file if found, else takes timestamp\n    from the basename. In future could read actual times from TIM files\n    (but range usually &lt;0.1 lst for a given image).\n    \"\"\"\n    lons = [minlon, maxlon] if maxlon else [minlon]\n    # Try to read time from M3 label file, if exists, else infer from basename\n    try:\n        lbl = get_m3_headers(basename, imgs=\"lbl\")\n        meta = parse_envi_header(lbl)\n        utcs = [meta[\"START_TIME\"], meta[\"STOP_TIME\"]]\n    except FileNotFoundError:\n        utcs = [m3basename2utc(basename)]\n    tlocs = []\n    for utc in utcs:\n        for lon in lons:\n            tlocs.append(lst2tloc(utc2lstmoon(utc, lon)))\n    return min(tlocs), max(tlocs)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.ibd3um","title":"<code>ibd3um(spec, wl1=2.697, wl2=2.936)</code>","text":"<p>Return 3um Integrated Band Depth from spec between (wl1, wl2). Equation 13 (Grumpe et al., 2019).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def ibd3um(spec, wl1=2.697, wl2=2.936):\n\"\"\"\n    Return 3um Integrated Band Depth from spec between (wl1, wl2).\n    Equation 13 (Grumpe et al., 2019).\n    \"\"\"\n    wl1, wl2 = sel_nearest(spec, \"wavelength\", (wl1, wl2))\n    spec_oh = spec.sel(wavelength=slice(wl1, wl2))\n    ibd = 100 * (1 - spec_oh).integrate(\"wavelength\")\n    dwl = wl2 - wl1\n    return ibd / dwl\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.index_m3xoak","title":"<code>index_m3xoak(ds, opts=None)</code>","text":"<p>Return ds with 2D xoak index set from loc file.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def index_m3xoak(ds, opts=None):\n\"\"\"Return ds with 2D xoak index set from loc file.\"\"\"\n    # Default kdtree opts (from timing global data and 300x1000 pix output)\n    if opts is None:\n        opts = dict(leafsize=512, balanced_tree=False, compact_nodes=False)\n    ds.xoak.set_index([\"lat\", \"lon\"], \"scipy_kdtree\", **opts)\n    return ds\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.is_targeted","title":"<code>is_targeted(m3img)</code>","text":"<p>Return True if m3img has 256 bands (targeted mode) rather than 85.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def is_targeted(m3img):\n\"\"\"\n    Return True if m3img has 256 bands (targeted mode) rather than 85.\n    \"\"\"\n    if isinstance(m3img, bool):\n        return m3img\n    if isinstance(m3img, str):\n        return m3img.startswith(\"M3T\")  # Check M3G or M3T\n    m3img = np.atleast_1d(m3img)\n    return m3img.shape[-1] == 256  # Check if shape 85 or 256\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.lin_contin","title":"<code>lin_contin(spec, wl1=2.537, wl2=2.657)</code>","text":"<p>Return slope and intercept of linear continuum between wl1 and wl2.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def lin_contin(spec, wl1=2.537, wl2=2.657):\n\"\"\"Return slope and intercept of linear continuum between wl1 and wl2.\"\"\"\n    wl1, wl2 = sel_nearest(spec, \"wavelength\", (wl1, wl2))\n    slope = (spec.sel(wavelength=wl2) - spec.sel(wavelength=wl1)) / (wl2 - wl1)\n    intercept = spec.sel(wavelength=wl1) - slope * wl1\n    return slope, intercept\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.lon180","title":"<code>lon180(lon)</code>","text":"<p>Convert lon to (-180, 180).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def lon180(lon):\n\"\"\"Convert lon to (-180, 180).\"\"\"\n    return (lon + 180) % 360 - 180\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.lon360","title":"<code>lon360(lon)</code>","text":"<p>Convert lon to (0, 360).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def lon360(lon):\n\"\"\"Convert lon to (0, 360).\"\"\"\n    return (lon + 360) % 360\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.lst2tloc","title":"<code>lst2tloc(lst)</code>","text":"<p>Return decimal local time [hr] from lst [hr,min,sec] (spice et2lst).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def lst2tloc(lst):\n\"\"\"Return decimal local time [hr] from lst [hr,min,sec] (spice et2lst).\"\"\"\n    return lst[0] + lst[1] / 60 + lst[2] / 3600\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.m3_refl","title":"<code>m3_refl(basename, ext, wls=None, kwin=KWIN, kwre={})</code>","text":"<p>Return M3 reflectance using the Tai Udovicic et al (2022) roughness thermal correction (updated from Bandfield et al., 2018). Uses ray-casting generated shadow_lookup table, KRC temperature table and applies standard M3 processing steps (empirical photometric correction).</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def m3_refl(basename, ext, wls=None, kwin=KWIN, kwre={}):\n\"\"\"\n    Return M3 reflectance using the Tai Udovicic et al (2022) roughness\n    thermal correction (updated from Bandfield et al., 2018).\n    Uses ray-casting generated shadow_lookup table, KRC temperature table and\n    applies standard M3 processing steps (empirical photometric correction).\n\n    \"\"\"\n    chunks = kwin.pop(\"chunks\", False)\n    kwin[\"dask\"] = False\n    obs = subset_m3xr_ext(get_m3xr(basename, \"obs\", **kwin), ext)\n    alb = get_albedo_feng(obs.lon, obs.lat)\n    if isinstance(ext, dict):\n        ext = [\n            float(e)\n            for e in (\n                obs.lon.min(),\n                obs.lon.max(),\n                obs.lat.min(),\n                obs.lat.max(),\n            )\n        ]\n    tloc = np.mean(get_tloc_range_spice(basename, ext[0], ext[1]))\n    ls = get_ls_spice(basename)  # Solar longitude (L_s)\n    wls = get_m3_wls(basename) if wls is None else wls\n    wls = rh.wl2xr(wls)\n\n    # Get rough emission\n    i, iaz, e, eaz, g = get_m3_geom_xr(obs, None)  # TODO: dem\n    args = (i, iaz, e, eaz, alb, wls, tloc, ls)\n    if chunks:\n        # emission = xr.map_blocks(get_emission_xr, i, args, kwre, template=(i*wls))\n        # emission = emission.load()  # Compute emission on chunks with dask\n        chunks[\"wavelength\"] = chunks.pop(\"band\")\n        emission = xr.zeros_like(i * wls).chunk(chunks)\n        emission = map_blocks(\n            emission_xr_helper, emission, *args, ind_dims=i.dims, **kwre\n        )\n    else:\n        emission = get_emission_xr(*args, **kwre)\n    emission = emission.transpose(\n        \"wavelength\", \"y\", \"x\"\n    )  # TODO check order earlier\n\n    # Remove emission from rad and convert to I/F\n    rad = subset_m3xr_ext(get_m3xr(basename, \"rad\", **kwin), ext)\n    L_sun = get_solar_irradiance_xr(basename, obs)\n    photom = get_m3photom(i, e, g, basename)\n    refl = re.get_rad_factor(rad, L_sun, emission, 1) * photom\n    refl.attrs = rad.attrs\n    return refl, emission\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.m3_size_est","title":"<code>m3_size_est(basename, ext)</code>","text":"<p>Return estimates number of pixels from M3img name and extent.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def m3_size_est(basename, ext):\n\"\"\"Return estimates number of pixels from M3img name and extent.\"\"\"\n    mpp_res = get_m3_res(basename)\n    ppd_res = mpp2ppd(mpp_res, lat=np.mean(ext[2:]))\n    xsize = ppd_res * (ext[1] - ext[0])\n    ysize = ppd_res * (ext[3] - ext[2])\n    zsize = len(get_m3_wls(basename))\n    pixels = int(xsize * ysize)\n    data_size = pixels * zsize * 8 / 1e6  # MB assuming 8 bit float\n    return pixels, data_size\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.m3_wl_to_ind","title":"<code>m3_wl_to_ind(wl, img)</code>","text":"<p>Get index and nearest wavelength of img given wl in nanometers.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def m3_wl_to_ind(wl, img):\n\"\"\"\n    Get index and nearest wavelength of img given wl in nanometers.\n    \"\"\"\n    return wl_to_ind(wl, get_m3_wls(img))\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.m3basename2utc","title":"<code>m3basename2utc(basename, fmt='%Y-%m-%dT%H:%M:%S')</code>","text":"<p>Return UTC time from m3 basename.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def m3basename2utc(basename, fmt=\"%Y-%m-%dT%H:%M:%S\"):\n\"\"\"Return UTC time from m3 basename.\"\"\"\n    return get_m3_date(basename).strftime(fmt)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.map_blocks","title":"<code>map_blocks(func, outda, *args, ind_dims=None, **kwargs)</code>","text":"<p>Map func to blocks of args.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def map_blocks(func, outda, *args, ind_dims=None, **kwargs):\n\"\"\"Map func to blocks of args.\"\"\"\n    # Magic to get dask chunk slices as list of multiple indices\n    if ind_dims is None:\n        ind_dims = outda.dims\n    cranges = []\n    for dim, chunks in zip(outda.dims, outda.chunks):\n        if dim in ind_dims:\n            cedges = np.r_[[0], np.cumsum(chunks)]\n            cranges.append(zip(cedges[:-1], cedges[1:]))\n    inds = [\n        tuple(slice(*ind) for ind in inds) for inds in it.product(*cranges)\n    ]\n\n    # Run in parallel\n    with mp.Pool(NCPUS) as pool:\n        args = zip(inds, it.repeat(args), it.repeat(kwargs))\n        out = pool.starmap(func, args, chunksize=1)\n    # Get results\n    for i, ind in enumerate(inds):\n        # func(ind, args, kwargs)\n        outda.data[ind] = out[i]\n    return outda\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.mpp2ppd","title":"<code>mpp2ppd(mpp, lat=0, Rmoon=1737.4)</code>","text":"<p>Convert lunar meters / pixel to pixels / degree resolution at lat.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def mpp2ppd(mpp, lat=0, Rmoon=1737.4):\n\"\"\"Convert lunar meters / pixel to pixels / degree resolution at lat.\"\"\"\n    circum_eq = 2 * np.pi * Rmoon * 1000  # m\n    circum_lat = circum_eq * np.cos(lat)\n    ppd = (circum_lat / mpp) / 360\n    return ppd\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.parse_envi_header","title":"<code>parse_envi_header(fname)</code>","text":"<p>Return dictionary of parameters in the envi header.</p> <p>TODO: port to open planetary package</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def parse_envi_header(fname):\n\"\"\"\n    Return dictionary of parameters in the envi header.\n\n    TODO: port to open planetary package\n    \"\"\"\n    params = {}\n    with open(fname, encoding=\"utf8\") as f:\n        key, value = \"\", \"\"\n        line = f.readline()\n        while line:\n            if isinstance(value, list):\n                if \"}\" in line:\n                    value.append(  # pylint: disable=E1101\n                        line.split(\"}\")[0].strip()\n                    )\n                    params[key] = list(filter(None, value))\n                    value = \"\"\n                else:\n                    value.append(line.strip(\" \\t\\n,\"))\n            elif \"=\" in line:\n                key, value = line.split(\"=\")\n                key, value = key.strip(), value.strip()\n                if value == \"{\":\n                    value = []\n                elif \"DESCRIPTION\" in key and line.count('\"') == 1:\n                    # Parse multi-line description\n                    values = [value]\n                    line = f.readline()\n                    while line and line.count('\"') != 1:\n                        values.append(line.strip())\n                        line = f.readline()\n                    values.append(line.strip())\n                    params[key] = \" \".join(values)\n                else:\n                    params[key] = value.strip('\"')\n            line = f.readline()\n    return params\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.read_albedo_map_feng","title":"<code>read_albedo_map_feng(plot=False, falbedo=FALBEDO, amin=0.04, amax=0.22)</code>","text":"<p>Return normal bolometric bond albedo albedo map from Feng et al. (2020).</p> <p>https://doi.org/10.5281/zenodo.3575481</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def read_albedo_map_feng(plot=False, falbedo=FALBEDO, amin=0.04, amax=0.22):\n\"\"\"\n    Return normal bolometric bond albedo albedo map from Feng et al. (2020).\n\n    https://doi.org/10.5281/zenodo.3575481\n    \"\"\"\n    df = pd.read_csv(falbedo, header=None, delimiter=r\"\\s+\")\n    lats = np.linspace(90, -90, len(df))\n    lon = np.linspace(-180, 180, len(df.columns))\n    albmap = xr.DataArray(df, coords=[lats, lon], dims=[\"lat\", \"lon\"])\n    albmap.name = \"albedo\"\n    if plot:\n        albmap.plot.imshow(size=5, aspect=len(albmap.lon) / len(albmap.lat))\n    return albmap.clip(amin, amax)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.read_m3_geotiff","title":"<code>read_m3_geotiff(fname, ext, pad=False)</code>","text":"<p>Return M3 image from file f with extent ext using rasterio.</p>"},{"location":"reference/m3_correction/#m3_correction.read_m3_geotiff--parameters","title":"Parameters","text":"<p>f (str): path to file ext (tuple): (latmin, latmax, lonmin, lonmax) pad (bool): pad image to match extent of ext</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def read_m3_geotiff(fname, ext, pad=False):\n\"\"\"\n    Return M3 image from file f with extent ext using rasterio.\n\n    Parameters\n    ----------\n    f (str): path to file\n    ext (tuple): (latmin, latmax, lonmin, lonmax)\n    pad (bool): pad image to match extent of ext\n    \"\"\"\n    left, right, bot, top = ext\n    with rio.open(fname) as src:\n        w = rio.windows.from_bounds(left, bot, right, top, src.transform)\n        img = rio2xy(src.read(window=w))\n        if pad:\n            img = rio_pad(img, ext, w, src.transform)\n    return img\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.read_m3_geotiff_ext","title":"<code>read_m3_geotiff_ext(fname, ext)</code>","text":"<p>Read M3 geotiff with ext (minlon, maxlon, minlat, maxlat)</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def read_m3_geotiff_ext(fname, ext):\n\"\"\"Read M3 geotiff with ext (minlon, maxlon, minlat, maxlat)\"\"\"\n    with rio.open(fname) as src:\n        w = ext2window(ext, src.transform)\n        img = src.read(window=w)\n        img = rio2xy(img)\n        img = rio_pad(img, ext, w, src.transform)\n        if src.count == 1 and len(img.shape) &gt; 2:\n            img = img[:, :, 0]\n    return img\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.read_m3_image","title":"<code>read_m3_image(hdr_path, ymin=0, ymax=None, xmin=0, xmax=None)</code>","text":"<p>Return np.array() with subset of m3 image with rasterio. Assumes the image is in the same directory as the header in hdr_path.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def read_m3_image(hdr_path, ymin=0, ymax=None, xmin=0, xmax=None):\n\"\"\"\n    Return np.array() with subset of m3 image with rasterio. Assumes the\n    image is in the same directory as the header in hdr_path.\n    \"\"\"\n    ext = \".IMG\" if hdr_path[-1].isupper() else \".img\"\n    fname = hdr_path[:-4] + ext\n    with rio.open(fname) as src:\n        rwindow = rio.windows.Window.from_slices(\n            (ymin, ymax), (xmin, xmax), width=src.width, height=src.height\n        )\n        img = rio2xy(src.read(window=rwindow))\n\n    return img\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.read_m3_rois","title":"<code>read_m3_rois(roi_path, sort_by_size=False)</code>","text":"<p>Return dict of rois from roi_path.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def read_m3_rois(roi_path, sort_by_size=False):\n\"\"\"Return dict of rois from roi_path.\"\"\"\n    with open(roi_path, encoding=\"utf8\") as f:\n        prio = json.load(f)\n    if sort_by_size:\n        size = []\n        for k, v in prio.items():\n            ext, *basenames = v\n            size.append([m3_size_est(basenames[0], ext)[1], k])\n        prio = {k: prio[k] for _, k in sorted(size)}\n    return prio\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.readm3geotif_xr","title":"<code>readm3geotif_xr(fname, ext)</code>","text":"<p>Read M3 geotiff and return xarray</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def readm3geotif_xr(fname, ext):\n\"\"\"\n    Read M3 geotiff and return xarray\n    \"\"\"\n    da = xr.open_dataarray(fname)\n    if \"wavelength\" in da.attrs:\n        wls = np.array(da.attrs[\"long_name\"], dtype=float) / 1000\n        da = da.assign_coords(wavelength=(\"band\", wls))\n        da = da.swap_dims({\"band\": \"wavelength\"}).drop(\"band\")\n        del da.attrs[\"wavelength\"]\n        del da.attrs[\"long_name\"]\n    elif \"long_name\" in da.attrs:\n        da = da.assign_coords(labels=(\"band\", np.array(da.attrs[\"long_name\"])))\n        del da.attrs[\"long_name\"]\n\n    da = da.rename({\"x\": \"lon\", \"y\": \"lat\"}).sortby(\"lat\")\n    da = da.sel(lon=slice(ext[0], ext[1]), lat=slice(ext[2], ext[3]))\n    return da.transpose(\"lat\", \"lon\", *set(da.dims).difference({\"lat\", \"lon\"}))\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.rio2xy","title":"<code>rio2xy(arr)</code>","text":"<p>Swap axes from [(bands), rows, columns] to [x, y, (bands)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def rio2xy(arr):\n\"\"\"Swap axes from [(bands), rows, columns] to [x, y, (bands)].\"\"\"\n    if len(arr.shape) == 3:\n        arr = np.moveaxis(arr, [0, 1, 2], [2, 1, 0])\n    elif len(arr.shape) == 2:\n        arr = np.moveaxis(arr, 0, 1)\n    return arr\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.rio_pad","title":"<code>rio_pad(arr, ext, w, transform, fill_value=np.nan)</code>","text":"<p>Zero-pad a rasterio windowed read array to shape of full extent</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def rio_pad(arr, ext, w, transform, fill_value=np.nan):\n\"\"\"Zero-pad a rasterio windowed read array to shape of full extent\"\"\"\n    if len(arr.shape) == 2:\n        arr = arr[:, :, np.newaxis]\n    arr_width, arr_height, bands = arr.shape\n    res = transform[0]  # deg/pixel\n    wbounds = rio.transform.array_bounds(w.height, w.width, transform)\n    ext_bounds = (ext[0], ext[2], ext[1], ext[3])\n    # Compute bounds of full extent output image\n    ext_width = int(round((ext_bounds[2] - ext_bounds[0]) / res))  # pixels\n    ext_height = int(round((ext_bounds[3] - ext_bounds[1]) / res))  # pixels\n    # Get coords of window in extent sized image\n    ymax = int(round((ext_bounds[3] - wbounds[3]) / res))\n    xmin = int(round((wbounds[0] - ext_bounds[0]) / res))\n    # Init extent-sized output\n    out = np.full((ext_width, ext_height, bands), fill_value)\n    if (ymax &gt; 0) and (xmin &gt; 0):\n        out[xmin : xmin + arr_width, ymax : ymax + arr_height, :] = arr\n    elif ymax &gt; 0:\n        out[:arr_width, ymax : ymax + arr_height, :] = arr\n    elif xmin &gt; 0:\n        out[xmin : xmin + arr_width, :arr_height, :] = arr\n    else:\n        out[:arr_width, :arr_height, :] = arr\n    return out\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.sel_m3xoak","title":"<code>sel_m3xoak(ds, lats, lons)</code>","text":"<p>Return xarray of m3 data at lats, lons using xoak index.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def sel_m3xoak(ds, lats, lons):\n\"\"\"\n    Return xarray of m3 data at lats, lons using xoak index.\n    \"\"\"\n    if ds.xoak.index is None:\n        raise ValueError(\"Must have xoak index set (see index_m3_xoak).\")\n\n    # Make (lat, lon) xoak selector\n    sel = xr.Dataset(\n        {\n            \"lat\": ((\"y\", \"x\"), np.tile(lats, (len(lons), 1))),\n            \"lon\": ((\"y\", \"x\"), np.tile(lons, (len(lats), 1)).T),\n        }\n    )\n    return ds.xoak.sel(lat=sel.lat, lon=sel.lon)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.sel_nearest","title":"<code>sel_nearest(da, coord, x)</code>","text":"<p>Return nearest coord value of each x (or index of x) in xarr.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def sel_nearest(da, coord, x):\n\"\"\"Return nearest coord value of each x (or index of x) in xarr.\"\"\"\n    scalar = np.isscalar(x)\n    x = [x] if scalar else x\n    nearest = []\n    for val in x:\n        nearest.append(da[coord].sel({coord: val}, method=\"nearest\").values)\n    return nearest[0] if scalar else nearest\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.subset_m3xr_ext","title":"<code>subset_m3xr_ext(da, ext, fill_bb=False)</code>","text":"<p>Return m3 da subsetted to lat/lon ext [minlon, maxlon, minlat, maxlat].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def subset_m3xr_ext(da, ext, fill_bb=False):\n\"\"\"\n    Return m3 da subsetted to lat/lon ext [minlon, maxlon, minlat, maxlat].\n    \"\"\"\n    warnings.filterwarnings(\"ignore\")  # Dask chunk performance warning\n    if isinstance(ext, dict):\n        subda = da.sel(ext)\n    else:\n        subda = da.where(\n            (lon360(ext[0]) + 360 &lt;= da.lon + 360)\n            &amp; (da.lon + 360 &lt;= lon360(ext[1]) + 360)\n            &amp; (ext[2] &lt;= da.lat)\n            &amp; (da.lat &lt;= ext[3]),\n            drop=True,\n        )\n    # if fill_bb: # TODO: fix\n    #     dims = list({*da.lon.dims} | {*da.lat.dims})  # {'y', 'x'} or {'lon', 'lat'}\n    #     dinds = [i for i, d in enumerate(subda.dims) if d in dims]\n    #     dmin = np.min(np.where(subda.notnull()), 1)[dinds]\n    #     dmax = np.max(np.where(subda.notnull()), 1)[dinds]\n    #     subda = da.where(\n    #         (dmin[0] &lt;= da[dims[0]])\n    #         &amp; (da[dims[0]] &lt;= dmax[0])\n    #         &amp; (dmin[1] &lt;= da[dims[1]])\n    #         &amp; (da[dims[1]] &lt;= dmax[1]), drop=True\n    #     )\n    # sel = {d: slice(dmin[i], dmax[i]) for i, d in zip(dinds, dims)}\n    # subda = da.isel(sel)\n    if subda.chunks is not None:\n        chunks = {d: None for d in subda.dims}\n        chunks[\"y\"] = \"auto\"\n        subda.chunk(chunks)\n    return subda\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.utc2lsmoon","title":"<code>utc2lsmoon(utc)</code>","text":"<p>Return solar longitude (L_s) [deg] from utc date using spiceypy.</p> <p>Technically returns Earth's L_s since this is expected by KRC.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def utc2lsmoon(utc):\n\"\"\"\n    Return solar longitude (L_s) [deg] from utc date using spiceypy.\n\n    Technically returns Earth's L_s since this is expected by KRC.\n    \"\"\"\n    if spiceypy.ktotal(\"ALL\") == 0:\n        furnsh_kernels()\n    et = spiceypy.str2et(utc)\n    ls = spiceypy.spiceypy.lspcn(\"EARTH\", et, \"NONE\")\n    return np.rad2deg(ls)\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.utc2lstmoon","title":"<code>utc2lstmoon(utc, lon)</code>","text":"<p>Return lunar local solar time at utc [yyyy-mm-ddThh:mm:ss] and lon [deg]. Uses spiceypy. Moon is NAIF ID 301.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def utc2lstmoon(utc, lon):\n\"\"\"\n    Return lunar local solar time at utc [yyyy-mm-ddThh:mm:ss] and lon [deg].\n    Uses spiceypy. Moon is NAIF ID 301.\n    \"\"\"\n    if spiceypy.ktotal(\"ALL\") == 0:\n        furnsh_kernels()\n    et = spiceypy.str2et(utc)\n    lst = spiceypy.spiceypy.et2lst(et, 301, np.deg2rad(lon), \"PLANETOGRAPHIC\")\n    return lst\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.utc2sdistmoon","title":"<code>utc2sdistmoon(utc)</code>","text":"<p>Return solar distance [AU] from utc date using spiceypy.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def utc2sdistmoon(utc):\n\"\"\"Return solar distance [AU] from utc date using spiceypy.\"\"\"\n    if spiceypy.ktotal(\"ALL\") == 0:\n        furnsh_kernels()\n    et = spiceypy.utc2et(utc)\n    pos = spiceypy.spkpos(\"SUN\", et, \"J2000\", \"NONE\", \"MOON\")[0]\n    sdist = spiceypy.convrt(spiceypy.vnorm(pos), \"KM\", \"AU\")\n    return sdist\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.wl_to_ind","title":"<code>wl_to_ind(wl, wavelengths)</code>","text":"<p>Return index of wl in wavelengths.</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def wl_to_ind(wl, wavelengths):\n\"\"\"Return index of wl in wavelengths.\"\"\"\n    ind = np.argmin(np.abs(np.array(wavelengths) - wl))\n    return ind, wavelengths[ind]\n</code></pre>"},{"location":"reference/m3_correction/#m3_correction.xy2np","title":"<code>xy2np(arr)</code>","text":"<p>Swap axes from [x, y, (bands)] to [rows, columns, (bands)].</p> Source code in <code>roughness/m3_correction.py</code> <pre><code>def xy2np(arr):\n\"\"\"Swap axes from [x, y, (bands)] to [rows, columns, (bands)].\"\"\"\n    if len(arr.shape) == 3:\n        arr = np.moveaxis(arr, [0, 1, 2], [1, 0, 2])\n    elif len(arr.shape) == 2:\n        arr = np.moveaxis(arr, 0, 1)\n    return arr\n</code></pre>"},{"location":"reference/make_los_table/","title":"make_los_table","text":"<p>Generate line of sight lookup tables.</p>"},{"location":"reference/make_los_table/#make_los_table.bin_slope_azim","title":"<code>bin_slope_azim(az, slope, az_bins, slope_bins)</code>","text":"<p>Return count of facets in each slope, azim bin using 2d histogram.</p>"},{"location":"reference/make_los_table/#make_los_table.bin_slope_azim--parameters","title":"Parameters","text":"<p>slope (1D or 2D arr): Facet slope values. az (1D or 2D arr): Facet azim values. slope_bins (1D arr): Bin edges of slopes. az_bins (1D arr): Bin edges of azims.</p>"},{"location":"reference/make_los_table/#make_los_table.bin_slope_azim--return","title":"Return","text":"<p>counts (2D arr nslope, naz): Counts in each slope/az bin; shape defined by bins.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def bin_slope_azim(az, slope, az_bins, slope_bins):\n\"\"\"\n    Return count of facets in each slope, azim bin using 2d histogram.\n\n    Parameters\n    ----------\n    slope (1D or 2D arr): Facet slope values.\n    az (1D or 2D arr): Facet azim values.\n    slope_bins (1D arr): Bin edges of slopes.\n    az_bins (1D arr): Bin edges of azims.\n\n    Return\n    ------\n    counts (2D arr nslope, naz): Counts in each slope/az bin; shape defined by bins.\n    \"\"\"\n    h = np.histogram2d(slope.ravel(), az.ravel(), bins=(slope_bins, az_bins))\n    counts = h[0].T  # Hist 2D transposes output\n    return counts\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.buffered_raytrace","title":"<code>buffered_raytrace(dem, inc, az=270)</code>","text":"<p>Return line of sight array for dem, with left portion of dem repeated by leftbuffer then removed from the output. This is intended to extend a randomly rough dem to the west to correct for the longest shadow distance possible in the raytrace (otherwise we undercount shadows).</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def buffered_raytrace(dem, inc, az=270):\n\"\"\"\n    Return line of sight array for dem, with left portion of dem repeated by\n    leftbuffer then removed from the output. This is intended to extend a\n    randomly rough dem to the west to correct for the longest shadow distance\n    possible in the raytrace (otherwise we undercount shadows).\n    \"\"\"\n    # Compute buffer, left of which we may be missing shadows\n    buf = get_dem_los_buffer(dem, inc)\n    if az != 270:\n        raise ValueError(\"Az must be 270 for this func. Try normal raytrace()\")\n\n    # Max buffer is dem width (if we need to double the dem, use a bigger one)\n    if buf &gt; dem.shape[0]:\n        msg = (\n            f\"Supplied {dem.shape} DEM is too small for raytracing \"\n            + f\"at inc={inc}. Use a DEM at least \"\n            + f\"{buf} pixels or specify smaller inc.\"\n        )\n        raise ValueError(msg)\n    los = raytrace(np.vstack((dem[:buf, :], dem)), inc, az)\n    return los[buf:, :]  # Remove left buffer and retranspose\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.get_dem_los_buffer","title":"<code>get_dem_los_buffer(dem, inc)</code>","text":"<p>Return in_buffer, sections of dem too close to the edge to have shadows.</p> <p>Since dem is of finite size and illuminated from the West at some inc, some facets towards the left edge of dem cannot have shadows cast onto them. We compute the max possible shadow length and exclude pixels within that length from the western edge of dem.</p>"},{"location":"reference/make_los_table/#make_los_table.get_dem_los_buffer--parameters","title":"Parameters","text":"<p>dem (2D arr): Input DEM to ray trace where values are z-height. inc (1D arr): Input vector incidence angle (0 is nadir).</p>"},{"location":"reference/make_los_table/#make_los_table.get_dem_los_buffer--return","title":"Return","text":"<p>buffer (int): Number of pixels to exclude from western edge of dem.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def get_dem_los_buffer(dem, inc):\n\"\"\"\n    Return in_buffer, sections of dem too close to the edge to have shadows.\n\n    Since dem is of finite size and illuminated from the West at some inc, some\n    facets towards the left edge of dem cannot have shadows cast onto them. We\n    compute the max possible shadow length and exclude pixels within that\n    length from the western edge of dem.\n\n    Parameters\n    ----------\n    dem (2D arr): Input DEM to ray trace where values are z-height.\n    inc (1D arr): Input vector incidence angle (0 is nadir).\n\n    Return\n    ------\n    buffer (int): Number of pixels to exclude from western edge of dem.\n    \"\"\"\n    # Find peak-to-peak of DEM (max - min)\n    elev_span = np.ptp(dem)\n\n    # Calculate longest shadow for buffer. Round up for good measure\n    buffer = int(elev_span * np.tan(np.deg2rad(inc))) + 1\n    return buffer\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.get_rms","title":"<code>get_rms(y)</code>","text":"<p>Compute the root mean square of an array, usually a Y array.</p>"},{"location":"reference/make_los_table/#make_los_table.get_rms--parameters","title":"Parameters","text":"<p>y (vector array): Array of values where the variance needs to be computes.</p>"},{"location":"reference/make_los_table/#make_los_table.get_rms--returns","title":"Returns","text":"<p>RMS (value): The RMS value.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def get_rms(y):\n\"\"\"\n    Compute the root mean square of an array, usually a Y array.\n\n    Parameters\n    ----------\n    y (vector array): Array of values where the variance needs to be computes.\n\n    Returns\n    -------\n    RMS (value): The RMS value.\n    \"\"\"\n    return np.sqrt(np.mean(y**2.0))\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.get_slope_aspect","title":"<code>get_slope_aspect(dem, get_aspect=True)</code>","text":"<p>Return the instantaneous slope and aspect (if get_aspect) for dem.</p> <p>Both values derived using NumPy's gradient method by methods from:</p> <p>Ritter, Paul. \"A vector-based slope and aspect generation algorithm.\" Photogrammetric Engineering and Remote Sensing 53, no. 8 (1987): 1109-1111</p>"},{"location":"reference/make_los_table/#make_los_table.get_slope_aspect--parameters","title":"Parameters","text":"<p>dem(height) (2D array): A two dimensional array of elevation data. get_aspect (bool): Whether to also compute and return aspect (default True)</p>"},{"location":"reference/make_los_table/#make_los_table.get_slope_aspect--returns","title":"Returns","text":"<p>slope (2D array): A two dimensional array of slope data. aspect (2D array, optional): A two dimensional array of aspect data.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def get_slope_aspect(dem, get_aspect=True):\n\"\"\"\n    Return the instantaneous slope and aspect (if get_aspect) for dem.\n\n    Both values derived using NumPy's gradient method by methods from:\n\n    Ritter, Paul. \"A vector-based slope and aspect generation algorithm.\"\n    Photogrammetric Engineering and Remote Sensing 53, no. 8 (1987): 1109-1111\n\n    Parameters\n    ----------\n    dem(height) (2D array): A two dimensional array of elevation data.\n    get_aspect (bool): Whether to also compute and return aspect (default True)\n\n    Returns\n    -------\n    slope (2D array): A two dimensional array of slope data.\n    aspect (2D array, optional): A two dimensional array of aspect data.\n    \"\"\"\n    # We use the gradient function to return the dz_dx and dz_dy.\n    dz_dy, dz_dx = np.gradient(dem)\n\n    # Slope is returned in degrees through simple calculation.\n    # No windowing is done (e.g. Horn's method).\n    slope = np.rad2deg(np.arctan(np.sqrt(dz_dx**2 + dz_dy**2)))\n    if get_aspect:\n        aspect = np.rad2deg(np.arctan2(-dz_dy, dz_dx))\n        # Convert to clockwise about Y and restrict to (0, 360) from North\n        aspect = (90 + aspect) % 360\n        return slope, aspect\n    return slope\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf","title":"<code>load_zsurf(path=FZSURF)</code>  <code>cached</code>","text":"<p>Return z surface with self-affine roughness at path.</p>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf--parameters","title":"Parameters","text":"<p>path (optional: str): Path to zsurf numpy array</p>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf--returns","title":"Returns","text":"<p>zsurf (2D array): Artifical z surface with self-affine roughness.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>@lru_cache(1)\ndef load_zsurf(path=FZSURF):\n\"\"\"\n    Return z surface with self-affine roughness at path.\n\n    Parameters\n    ----------\n    path (optional: str): Path to zsurf numpy array\n\n    Returns\n    -------\n    zsurf (2D array): Artifical z surface with self-affine roughness.\n    \"\"\"\n    try:\n        zsurf = np.load(path, allow_pickle=True)\n    except FileNotFoundError:\n        zsurf = None\n    return zsurf\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf_scale_factors","title":"<code>load_zsurf_scale_factors(path=FZ_FACTORS)</code>  <code>cached</code>","text":"<p>Return scale factors at path.</p>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf_scale_factors--parameters","title":"Parameters","text":"<p>path (optional: str): Path to zsurf numpy array</p>"},{"location":"reference/make_los_table/#make_los_table.load_zsurf_scale_factors--returns","title":"Returns","text":"<p>scale_factors (1D array): : Scale factors for zsurf.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>@lru_cache(1)\ndef load_zsurf_scale_factors(path=FZ_FACTORS):\n\"\"\"\n    Return scale factors at path.\n\n    Parameters\n    ----------\n    path (optional: str): Path to zsurf numpy array\n\n    Returns\n    -------\n    scale_factors (1D array): : Scale factors for zsurf.\n    \"\"\"\n    try:\n        zsurf_factors = np.load(path)\n    except FileNotFoundError:\n        zsurf_factors = None\n    return zsurf_factors\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.make_conj_sym","title":"<code>make_conj_sym(inarray, n, phase=0)</code>","text":"<p>Takes square mag/phase arrays and impose conjugate symmetry for ifft.</p>"},{"location":"reference/make_los_table/#make_los_table.make_conj_sym--parameters","title":"Parameters","text":"<p>inarray: Square array that will be fed to ifft. n: Single axis dimension. phase: If the input is the phase portion of the complex FFT, set phase = 1.</p>"},{"location":"reference/make_los_table/#make_los_table.make_conj_sym--returns","title":"Returns","text":"<p>out: inarray modified to have conjugate symmetry.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def make_conj_sym(inarray, n, phase=0):\n\"\"\"\n    Takes square mag/phase arrays and impose conjugate symmetry for ifft.\n\n    Parameters\n    ----------\n    inarray: Square array that will be fed to ifft.\n    n: Single axis dimension.\n    phase: If the input is the phase portion of the complex FFT, set phase = 1.\n\n    Returns\n    -------\n    out: inarray modified to have conjugate symmetry.\n    \"\"\"\n    # Copy inarray for manipulation.\n    out = np.copy(inarray)\n\n    # Define critical indicies (e.g., DC, Nyquist positions)\n    DC = 0\n    Ny = int(n / 2)\n\n    # Set the critical indices to 0.\n    out[DC, DC] = 0\n    out[DC, Ny] = 0\n    out[Ny, Ny] = 0\n    out[Ny, DC] = 0\n\n    # Perform the Hermitian transpose. If input is phase, transpose is negative.\n    if phase == 0:\n        out[1:n, 1:Ny] = np.rot90(out[1:n, Ny + 1 : n], 2)\n        out[DC, 1:Ny] = np.rot90(\n            out[DC, Ny + 1 : n].reshape(-1, 1), 2\n        ).reshape(-1)\n        out[Ny + 1 : n, DC] = np.rot90(\n            out[1:Ny, DC].reshape(-1, 1), 2\n        ).reshape(-1)\n        out[Ny + 1 : n, Ny] = np.rot90(\n            out[1:Ny, Ny].reshape(-1, 1), 2\n        ).reshape(-1)\n\n    elif phase == 1:\n        out[1:n, 1:Ny] = -np.rot90(out[1:n, Ny + 1 : n], 2)\n        out[DC, 1:Ny] = -np.rot90(\n            out[DC, Ny + 1 : n].reshape(-1, 1), 2\n        ).reshape(-1)\n        out[Ny + 1 : n, DC] = -np.rot90(\n            out[1:Ny, DC].reshape(-1, 1), 2\n        ).reshape(-1)\n        out[Ny + 1 : n, Ny] = -np.rot90(\n            out[1:Ny, Ny].reshape(-1, 1), 2\n        ).reshape(-1)\n\n    # Return symmetric array.\n    return out\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.make_default_los_table","title":"<code>make_default_los_table()</code>","text":"<p>Return default los table.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def make_default_los_table():\n\"\"\"Return default los table.\"\"\"\n    # Load in the synthetic DEM and scale factors\n    zsurf = make_zsurf(DEMSIZE, default=True)\n    rmss, incs = np.array(RMSS), np.array(INCS)\n    return make_los_table(zsurf, rmss, incs, thresh=MIN_FACETS, fout=FLOOKUP)\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.make_los_table","title":"<code>make_los_table(zsurf, rmss, incs, naz=36, ntheta=45, thresh=1, az0=AZ0, fout=None)</code>","text":"<p>Generate line of sight probability table with dims (rms, inc, slope, az).</p> <p>Tables are generated using raytracing on a synthetic Gaussian surface with a range of RMS slopes and observed from a range of solar inc angles. Final los_prob table is binned by facet slope/azimuth:</p> <ul> <li>los_prob == 1: All facets in line of sight (i.e. visible / illuminated)</li> <li>los_prob == 0: No facets in line of sight (i.e. not visible / shadowed)</li> <li>los_prob == np.nan: Fewer than threshold facets observed in bin</li> </ul>"},{"location":"reference/make_los_table/#make_los_table.make_los_table--parameters","title":"Parameters","text":"<p>zsurf (n x n arr): Artifical z surface with self-affine roughness. rmss (arr): RMS slope of surface to raytrace incs (arr): Solar incidence angles to raytrace [degrees] naz (int): Number of facet azimuth bins. Default=36 ntheta (int): Number of facet slope bins. Default=45 thresh (int): Min facets in bin to assign probability. Default=1 az0 (float): Raytrace azimuth from north in degrees. Default=270 fout (str): Path to write table with xarray extension (e.g. \".nc\").</p>"},{"location":"reference/make_los_table/#make_los_table.make_los_table--returns","title":"Returns","text":"<p>xarray.Dataset with 3 DataArrays:     total: Total number of facets in bin     los: Number of facets in line of sight in bin     prob: Fraction of facets in line of sight in bin (los/total)</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def make_los_table(\n    zsurf, rmss, incs, naz=36, ntheta=45, thresh=1, az0=AZ0, fout=None\n):\n\"\"\"\n    Generate line of sight probability table with dims (rms, inc, slope, az).\n\n    Tables are generated using raytracing on a synthetic Gaussian surface with\n    a range of RMS slopes and observed from a range of solar inc angles. Final\n    los_prob table is binned by facet slope/azimuth:\n\n    - los_prob == 1: All facets in line of sight (i.e. visible / illuminated)\n    - los_prob == 0: No facets in line of sight (i.e. not visible / shadowed)\n    - los_prob == np.nan: Fewer than threshold facets observed in bin\n\n    Parameters\n    ----------\n    zsurf (n x n arr): Artifical z surface with self-affine roughness.\n    rmss (arr): RMS slope of surface to raytrace\n    incs (arr): Solar incidence angles to raytrace [degrees]\n    naz (int): Number of facet azimuth bins. Default=36\n    ntheta (int): Number of facet slope bins. Default=45\n    thresh (int): Min facets in bin to assign probability. Default=1\n    az0 (float): Raytrace azimuth from north in degrees. Default=270\n    fout (str): Path to write table with xarray extension (e.g. \".nc\").\n\n    Returns\n    -------\n    xarray.Dataset with 3 DataArrays:\n        total: Total number of facets in bin\n        los: Number of facets in line of sight in bin\n        prob: Fraction of facets in line of sight in bin (los/total)\n    \"\"\"\n    if thresh &lt; 1:\n        raise ValueError(\"Thresh must be &gt;= 1 to assign probability\")\n    # Get line of sight lookup coordinate arrays\n    azbins, slopebins = rh.get_facet_bins(naz, ntheta)\n\n    # Load or compute scale factors\n    # TODO: scale factors should be computed and associated with zsurf\n    if fout == FLOOKUP:\n        factors = make_scale_factors(zsurf, rmss, default=True)\n    elif fout is not None:\n        f_sf = Path(fout).stem + \"_scale_factors.npy\"\n        factors = make_scale_factors(zsurf, rmss, fout=f_sf)\n    else:\n        factors = make_scale_factors(zsurf, rmss)\n\n    # Init total and line of sight facet arrays with nodata value\n    # Dtype int since total and los facets are counts\n    tot_facets = np.full((len(rmss), len(incs), naz, ntheta), -999, dtype=int)\n    los_facets = np.copy(tot_facets)\n\n    # Rms=0 is flat and inc=0 is nadir (all los), inc=90 is horizon (no los)\n    # Skip raytracing these and handle below\n    rmss_sub = rmss[rmss &gt; 0]\n    incs_sub = incs[(incs &gt; 0) &amp; (incs &lt; 90)]\n    for r, rms in enumerate(rmss_sub):\n        # Scale the dem to the prescirbed RMS slope and get slope, azim arrays\n        dem = scale_dem(zsurf, rms, factors, rmss)\n        slope, azim = get_slope_aspect(dem)\n        azim = (azim + 270) % 360  # TODO: cludge, raytrace is rotating az\n\n        # Get binned counts of total facets in dem (doesn't change with inc)\n        tot_facets[r, :, :, :] = bin_slope_azim(azim, slope, azbins, slopebins)\n        for i, inc in enumerate(incs_sub):\n            # Run ray trace to compute dem facets in line of sight\n            # Buffered extends dem if needed to correct for longest shadow\n            los = buffered_raytrace(dem, inc, az0)\n\n            # Get binned counts of facets in los\n            los_facets[r, i, :, :] = bin_slope_azim(\n                azim[los], slope[los], azbins, slopebins\n            )\n\n            # Report progress\n            ni, nr = len(incs_sub), len(rmss_sub)\n            ppct = (r * ni + (i + 1)) / (ni * nr) * 100\n            pbar = \"=\" * int(ppct // 5)\n            print(f\"Raytracing [{pbar:20s}] {ppct:.2f}\", end=\"\\r\", flush=True)\n\n    print(\"\\nGenerating lineofsight lookup table...\")\n\n    # Setting inc=0 to 1 and inc=90 to 0 smooths interpolation of los_prob\n    inc_0 = np.where(incs == 0)\n    los_facets[:, inc_0] = tot_facets[:, inc_0]\n    los_facets[:, np.where(incs == 90)] = 0\n\n    # Set bins with fewer than threshold facets to nodata (prevents div 0)\n    tot_facets[tot_facets &lt; thresh] = -999\n\n    # Compute los_prob: fraction of facets in lineofsight / total facets in bin\n    los_prob = los_facets / tot_facets\n\n    # Clean up nodata values and make consistent across all lookups\n    nodata = (tot_facets == -999) | (los_facets == -999)\n\n    # Clean up jagged edges caused by bin count at theta being close to thresh\n    # If any az bin for a given theta slice is nan, set all az at theta to nan\n    rms_nan, inc_nan, theta_nan = np.where(np.any(nodata, axis=2))\n    tot_facets[rms_nan, inc_nan, :, theta_nan] = -999\n    los_facets[rms_nan, inc_nan, :, theta_nan] = -999\n    los_prob[rms_nan, inc_nan, :, theta_nan] = -999\n\n    # Setting rms=0 (flat surface) to 1 smooths interpolation of los_prob\n    rms_0 = np.where(rmss == 0)\n    tot_facets[rms_0, :, :, 0] = 1  # One facet at each az in 1st slope bin\n    los_facets[rms_0, :, :, 0] = 1  # Each flat facet is in los\n    los_prob[rms_0, :, :, 0] = 1  # Each flat facet has 100% chance of los\n\n    # Convert lookups to xarray\n    lookups = (tot_facets, los_facets, los_prob)\n    ds = rh.lookup2xarray(lookups, rmss, incs, nodata=-999)\n    ds.attrs[\"description\"] = \"Roughness line of sight lookup DataSet.\"\n    ds.attrs[\"version\"] = VERSION\n    ds.attrs[\"demsize\"] = zsurf.shape\n    ds.attrs[\"threshold\"] = thresh\n    ds.attrs[\"az0\"] = az0\n\n    if fout is not None:\n        try:\n            ds.to_netcdf(fout, mode=\"w\")\n        except PermissionError as e:\n            print(e)\n            fout = fout + \".tmp\"\n            ds.to_netcdf(fout, mode=\"w\")\n        print(f\"Wrote {fout}\")\n    return ds\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.make_scale_factors","title":"<code>make_scale_factors(zsurf, rms_arr, write=True, fout=FZ_FACTORS, default=False)</code>","text":"<p>Determine scale factors that produce rms_arr slopes from zsurf.</p> <p>Computes RMS slope of zsurf at several multiplicative scale factors, then interpolates to find scale_factors at desired rms_arr values.</p>"},{"location":"reference/make_los_table/#make_los_table.make_scale_factors--parameters","title":"Parameters","text":"<p>zsurf (n x n arr): Artifical z surface with self-affine roughness. rms_arr (arr): Array of RMS values to scale zsurf to (max 80 degrees). write (bool): Write out scale factors to file. fout (str): Path to write scale factors. default (bool): Use default scale factors if they exist.</p>"},{"location":"reference/make_los_table/#make_los_table.make_scale_factors--returns","title":"Returns","text":"<p>scale_factors (arr): Factors to scale zsurf by to get each rms_arr value.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def make_scale_factors(\n    zsurf, rms_arr, write=True, fout=FZ_FACTORS, default=False\n):\n\"\"\"\n    Determine scale factors that produce rms_arr slopes from zsurf.\n\n    Computes RMS slope of zsurf at several multiplicative scale factors, then\n    interpolates to find scale_factors at desired rms_arr values.\n\n    Parameters\n    ----------\n    zsurf (n x n arr): Artifical z surface with self-affine roughness.\n    rms_arr (arr): Array of RMS values to scale zsurf to (max 80 degrees).\n    write (bool): Write out scale factors to file.\n    fout (str): Path to write scale factors.\n    default (bool): Use default scale factors if they exist.\n\n    Returns\n    -------\n    scale_factors (arr): Factors to scale zsurf by to get each rms_arr value.\n    \"\"\"\n    if not default:\n        fout = rh.fname_with_demsize(\n            fout, f\"{zsurf.shape[0]}_rmsmax_{max(rms_arr)}\"\n        )\n        # Try to load scale factors and check they are correct length\n        scale_factors = load_zsurf_scale_factors(fout)\n        if scale_factors is not None and len(scale_factors) == len(rms_arr):\n            print(f\"Loaded scale_factors from {fout}\")\n            return scale_factors\n\n    print(\"Calculating new scale factors...\")\n    # Scale factors from 0x to 10x in logspace (~0 to 80 degrees RMS)\n    factors = np.array([0, *np.logspace(-1, 2, 20)])\n    rms_derived = np.zeros_like(factors)\n    i = 1  # rms=0 is factor=0 so we start at 1\n    # Save RMS slope at each factor, end loop when we exceed max(rms_arr)\n    while rms_derived[i - 1] &lt; max(rms_arr) and i &lt; len(factors):\n        # Compute z surface * factor and get RMS\n        zsurf_new = zsurf * factors[i]\n        rms_derived[i] = get_rms(get_slope_aspect(zsurf_new, get_aspect=False))\n        i += 1\n\n    # Interpolate to get the factor at each rms in rms_arr (truncate at last i)\n    scale_factors = np.interp(rms_arr, rms_derived[:i], factors[:i])\n\n    if write:\n        np.save(fout, scale_factors)\n        print(f\"Wrote scale_factors to {fout}\")\n    return scale_factors\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.make_zsurf","title":"<code>make_zsurf(n=10000, H=0.8, qr=100, fout=FZSURF, write=True, default=False)</code>","text":"<p>Return a synthetic surface with self-affine roughness. Much of this is detailed in this paper: Tevis D B Jacobs et al 2017 Surf. Topogr.: Metrol. Prop. 5 013001 https://doi.org/10.1088/2051-672X/aa51f8</p>"},{"location":"reference/make_los_table/#make_los_table.make_zsurf--parameters","title":"Parameters","text":"<p>n: Side length of synthetic surface. Default=10000 H: Hurst exponent. qr: Rolloff wavelength in units of q (wavevector; 1/m). fout (str): Path to write z surface (.npy).</p>"},{"location":"reference/make_los_table/#make_los_table.make_zsurf--returns","title":"Returns","text":"<p>zsurf (n x n arr): Artifical z surface with self-affine roughness.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def make_zsurf(n=10000, H=0.8, qr=100, fout=FZSURF, write=True, default=False):\n\"\"\"\n    Return a synthetic surface with self-affine roughness.\n    Much of this is detailed in this paper:\n    Tevis D B Jacobs et al 2017 Surf. Topogr.: Metrol. Prop. 5 013001\n    https://doi.org/10.1088/2051-672X/aa51f8\n\n    Parameters\n    ----------\n    n: Side length of synthetic surface. Default=10000\n    H: Hurst exponent.\n    qr: Rolloff wavelength in units of q (wavevector; 1/m).\n    fout (str): Path to write z surface (.npy).\n\n    Returns\n    -------\n    zsurf (n x n arr): Artifical z surface with self-affine roughness.\n    \"\"\"\n    # Return zsurf from fout if it exists and is correct size\n    if not default:\n        fout = rh.fname_with_demsize(fout, n)\n        zsurf = load_zsurf(fout)\n        if zsurf is not None and zsurf.shape == (n, n):\n            print(f\"Loaded zsurf from {fout}\")\n            return zsurf\n\n    # Make sure the dimensions are even\n    print(\"Making new z surface...\")\n    if n % 2:\n        n = n - 1\n\n    # Detemine image lengths. This implementation is finite but can be\n    # modified for continuous wavevectors where q-&gt;infinity\n    pixelwidth = 1 / n\n\n    # Build the 1D wavevector, 1D FFT shift, unwrap to adjust for 2 pi phase.\n    q = (\n        np.unwrap(np.fft.fftshift(((2 * np.pi / n) * np.arange(n))))\n        - 2 * np.pi\n    ) / pixelwidth\n\n    # Create 2D mesh of the wavevector and convert to polar coordinates.\n    qxx, qyy = np.meshgrid(q, q)\n    rho, _ = rh.cart2pol(qxx, qyy)\n\n    # Make a 2D PSD zeros matrix and fill it with the polar rho values\n    # from the 2D wavevectors. First line account for the rolloff by making it\n    # constant. This also properly accounts for Hurst exponent by raising the\n    # wavevectors to (-2*(H+1))\n    Cq = np.zeros((n, n))\n    Cq[rho &lt; qr] = qr ** (-2 * (H + 1))\n    Cq[rho &gt;= qr] = rho[rho &gt;= qr] ** (-2 * (H + 1))\n\n    # The center of the PSD is the ifft mean. We set this to 0.\n    Cq[int(n / 2), int(n / 2)] = 0\n\n    # This section imposes conjugate symmetry for  mag/phase input to ifft\n    Bq = np.sqrt(Cq / (pixelwidth**2 / ((n * n) * ((2 * np.pi) ** 2))))\n    Bq = make_conj_sym(Bq, n)\n\n    # Here is where we introduce the randon gaussian portion.\n    noise = np.random.rand(n, n)\n    Phi = (2 * np.pi) * noise - np.pi\n    Phi = make_conj_sym(Phi, n, phase=1)\n\n    # Now we convert back to cartesian coordinates.\n    a, b = rh.pol2cart(Bq, Phi)\n\n    # Time to invert the FFT and generate our topography\n    # Need to allocate an empty complex array similar in size to our Bq.\n    out = np.empty_like(Bq, dtype=\"complex128\")\n\n    # NumPy complex arrays allow definition of the real and imaginary components.\n    out.real = a\n    out.imag = b\n\n    # Call the inverse FFT shift to put our low frequency stuff to the margins.\n    out = np.fft.ifftshift(out)\n\n    # And finally we call the inverse FFT.\n    # Because we went through all that trouble to make the array symmetric this\n    # should return a real, float array and make iFFT run faster.\n    zsurf = np.fft.ifft2(out)\n\n    # But it won't do that because of rounding so we call it real if close.\n    zsurf = np.real_if_close(zsurf)\n\n    # Because we are going to scale to various RMS slopes we want to normalize.\n    norm_zsurf = (zsurf - np.mean(zsurf)) / np.std(zsurf)\n\n    # Voila. A real array of height values with self-affine roughness.\n    # Save it!\n    if write:\n        np.save(fout, norm_zsurf)\n        print(f\"Wrote zsurf to {fout}\")\n    return norm_zsurf\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.raytrace","title":"<code>raytrace(dem, inc, az=270)</code>","text":"<p>Return line of sight boolean array of 2D dem viewed from (inc, azim).</p> <p>Wraps lineofsight raytrace module.</p>"},{"location":"reference/make_los_table/#make_los_table.raytrace--parameters","title":"Parameters","text":"<p>dem (2D arr): Input DEM to ray trace where values are z-height. inc (1D arr): Input vector incidence angle [0, 90) where 0 is nadir. az (1D arr): Input vector azimuth angle [0, 360) where 0 is North.</p>"},{"location":"reference/make_los_table/#make_los_table.raytrace--returns","title":"Returns","text":"<p>out (2D bool arr, dem.shape): True - in los; False - not in los</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def raytrace(dem, inc, az=270):\n\"\"\"\n    Return line of sight boolean array of 2D dem viewed from (inc, azim).\n\n    Wraps lineofsight raytrace module.\n\n    Parameters\n    ----------\n    dem (2D arr): Input DEM to ray trace where values are z-height.\n    inc (1D arr): Input vector incidence angle [0, 90) where 0 is nadir.\n    az (1D arr): Input vector azimuth angle [0, 360) where 0 is North.\n\n    Returns\n    -------\n    out (2D bool arr, dem.shape): True - in los; False - not in los\n    \"\"\"\n    # Make an input array where all values are illuminated\n    los = np.ones_like(dem)  # , order='F')\n    cols, rows = los.shape\n    # If inc == 0 all illuminated, if inc &gt;= 90 none illuminated\n    if inc == 0:\n        pass\n    elif inc &gt;= 90:\n        los *= 0\n    else:\n        # Passing inputs to the fortran module\n        # TODO: weird transpose passing back/forth from fortran (works for now)\n        los = lineofsight.lineofsight(\n            dem.ravel(order=\"F\"), inc, az, los, cols, rows\n        )\n    return los.astype(bool)\n</code></pre>"},{"location":"reference/make_los_table/#make_los_table.scale_dem","title":"<code>scale_dem(dem, rms, scale_factors, rmss)</code>","text":"<p>Scale a DEM by a set of scale factors.</p>"},{"location":"reference/make_los_table/#make_los_table.scale_dem--parameters","title":"Parameters","text":"<p>dem (n x n arr): DEM to scale. rms (int): RMS value to scale to. scale_factors (arr): Factors to scale dem by. rmss (arr): RMS values corresponding to scale_factors.</p>"},{"location":"reference/make_los_table/#make_los_table.scale_dem--returns","title":"Returns","text":"<p>scaled_dem (n x n arr): DEM scaled to have rms roughness.</p> Source code in <code>roughness/make_los_table.py</code> <pre><code>def scale_dem(dem, rms, scale_factors, rmss):\n\"\"\"\n    Scale a DEM by a set of scale factors.\n\n    Parameters\n    ----------\n    dem (n x n arr): DEM to scale.\n    rms (int): RMS value to scale to.\n    scale_factors (arr): Factors to scale dem by.\n    rmss (arr): RMS values corresponding to scale_factors.\n\n    Returns\n    -------\n    scaled_dem (n x n arr): DEM scaled to have rms roughness.\n    \"\"\"\n    # Find the closest scale factor to the desired rms\n    i = np.argmin(np.abs(rmss - rms))\n    # Scale the dem by the scale factor\n    return dem * scale_factors[i]\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":"<p>Helpers for plotting roughness tables and arrays.</p>"},{"location":"reference/plotting/#plotting.dem_imshow","title":"<code>dem_imshow(dem, xmin=None, xmax=None, ymin=None, ymax=None, band='slope', ax=None, title='', cmap='viridis', **kwargs)</code>","text":"<p>Use imshow to display a stacked DEM image (slope, azimuth, elevation).</p> <p>Parameters:</p> Name Type Description Default <code>dem</code> <code>ndarray</code> <p>A 3D stacked DEM (slope, azimuth, elevation).</p> required <code>xmin,</code> <code>xmax, ymin, ymax (int</code> <p>The x and y index ranges to plot.</p> required <code>band</code> <code>str or tuple</code> <p>The band to display. Valid values are 'slope',  'azim', 'elev', or a tuple of (0, 1, 2) respectively.</p> <code>'slope'</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on. If not provided,  a new Axes object will be generated.</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title (default: '')</p> <code>''</code> <code>cmap</code> <code>str</code> <p>Colormap (default: \"gray\").</p> <code>'viridis'</code> Source code in <code>roughness/plotting.py</code> <pre><code>def dem_imshow(\n    dem,\n    xmin=None,\n    xmax=None,\n    ymin=None,\n    ymax=None,\n    band=\"slope\",\n    ax=None,\n    title=\"\",\n    cmap=\"viridis\",\n    **kwargs,\n):\n\"\"\"\n    Use imshow to display a stacked DEM image (slope, azimuth, elevation).\n\n    Parameters:\n        dem (ndarray): A 3D stacked DEM (slope, azimuth, elevation).\n        xmin, xmax, ymin, ymax (int): The x and y index ranges to plot.\n        band (str or tuple): The band to display. Valid values are 'slope', \n            'azim', 'elev', or a tuple of (0, 1, 2) respectively.\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. If not provided, \n            a new Axes object will be generated.\n        title (str, optional): Plot title (default: '')\n        cmap (str, optional): Colormap (default: \"gray\").\n    \"\"\"\n    zmap = {\"slope\": 0, \"azim\": 1, \"elev\": 2, 0: \"slope\", 1: \"azim\", 2: \"elev\"}\n    if len(dem.shape) &gt; 2 and dem.shape[2] &gt; 1:\n        if isinstance(band, str) and band in zmap:\n            zind = zmap[band]\n        elif isinstance(band, int) and band in (0, 1, 2):\n            zind = band\n        else:\n            raise ValueError(f\"Unknown band {band} specified.\")\n        if title is None:\n            title = f\"DEM {zmap[zind]}\"\n    else:\n        zind = None\n    if ax is None:\n        _, ax = plt.subplots()\n    p = ax.imshow(dem[xmin:xmax, ymin:ymax, zind].T, cmap=cmap, **kwargs)\n    ax.set_title(title)\n    return p\n</code></pre>"},{"location":"reference/plotting/#plotting.m3_imshow","title":"<code>m3_imshow(img, xmin=None, xmax=None, ymin=None, ymax=None, wl=750, ax=None, title=None, cmap='gray', **kwargs)</code>","text":"<p>Use imshow to display an M3 image. Specify wavelength, wl, to show the closest channel to that wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>M3 image.</p> required <code>xmin,</code> <code>xmax, ymin, ymax (int</code> <p>The x and y index ranges to plot.</p> required <code>wl</code> <code>int</code> <p>Wavelength to show, gets nearest (default: 750nm).</p> <code>750</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on. If not provided,  a new Axes object will be generated.</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title (default: '')</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap (default: \"gray\").</p> <code>'gray'</code> Source code in <code>roughness/plotting.py</code> <pre><code>def m3_imshow(\n    img,\n    xmin=None,\n    xmax=None,\n    ymin=None,\n    ymax=None,\n    wl=750,\n    ax=None,\n    title=None,\n    cmap=\"gray\",\n    **kwargs,\n):\n\"\"\"\n    Use imshow to display an M3 image. Specify wavelength, wl, to show the\n    closest channel to that wavelength.\n\n    Parameters:\n        img (ndarray): M3 image.\n        xmin, xmax, ymin, ymax (int): The x and y index ranges to plot.\n        wl (int, optional): Wavelength to show, gets nearest (default: 750nm).\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. If not provided, \n            a new Axes object will be generated.\n        title (str, optional): Plot title (default: '')\n        cmap (str, optional): Colormap (default: \"gray\").\n    \"\"\"\n    band = 0 if len(img.shape) &gt; 2 else None\n    if ax is None:\n        _, ax = plt.subplots()\n    if len(img.shape) &gt; 2 and img.shape[2] &gt; 1:\n        band, wl = m3.m3_wl_to_ind(wl, img)\n        if title is None:\n            title = f\"M3 img: band {band+1} ({wl} nm)\"\n    p = ax.imshow(img[xmin:xmax, ymin:ymax, band].T, cmap=cmap, **kwargs)\n    ax.set_title(title)\n    return p\n</code></pre>"},{"location":"reference/plotting/#plotting.m3_spec","title":"<code>m3_spec(img, fmt='-', wls=None, ax=None, title=None, **kwargs)</code>","text":"<p>Plot M3 spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>M3 image.</p> required <code>fmt</code> <code>str</code> <p>Plot format (default: '-' for line).</p> <code>'-'</code> <code>wls</code> <code>ndarray</code> <p>Wavelengths to plot (default: all).</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on. If not provided,  a new Axes object will be generated.</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title (default: '')</p> <code>None</code> Source code in <code>roughness/plotting.py</code> <pre><code>def m3_spec(img, fmt=\"-\", wls=None, ax=None, title=None, **kwargs):\n\"\"\"\n    Plot M3 spectrum.\n\n    Parameters:\n        img (ndarray): M3 image.\n        fmt (str, optional): Plot format (default: '-' for line).\n        wls (ndarray, optional): Wavelengths to plot (default: all).\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. If not provided, \n            a new Axes object will be generated.\n        title (str, optional): Plot title (default: '')\n    \"\"\"\n    if title is None:\n        title = \"M3 spectrum\"\n    if ax is None:\n        _, ax = plt.subplots()\n    if len(img.shape) &gt; 2 and img.shape[2] &gt; 1:\n        m3wls, spec = m3.get_avg_spec(img, wls=wls)\n    else:\n        m3wls, spec = m3.get_spec(img, wls=wls)\n    if wls is None:\n        wls = m3wls\n    ax.plot(wls, spec, fmt, **kwargs)\n    ax.set_title(title)\n    ax.set_xlabel(\"Wavelength [microns]\")\n    return ax\n</code></pre>"},{"location":"reference/plotting/#plotting.plot_slope_az_table","title":"<code>plot_slope_az_table(table, cmap_r=False, clabel=None, title=None, ax=None, proj=None, vmin=None, vmax=None, extent=None, **kwargs)</code>","text":"<p>Plot a 2D line-of-sight table with facet slope vs facet azimuth.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>ndarray</code> <p>A 2D array of slope vs azimuth.</p> required <code>cmap_r</code> <code>bool</code> <p>Use a reverse colormap. Default is False.</p> <code>False</code> <code>clabel</code> <code>str</code> <p>Label for the colorbar. Default is an empty string.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on. If not provided,  a new Axes object will be generated.</p> <code>None</code> <code>proj</code> <code>str</code> <p>The projection to use. Valid values are 'polar' and None. Default is None.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value for the colorbar. Default is None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value for the colorbar. Default is None.</p> <code>None</code> Source code in <code>roughness/plotting.py</code> <pre><code>def plot_slope_az_table(\n    table,\n    cmap_r=False,\n    clabel=None,\n    title=None,\n    ax=None,\n    proj=None,\n    vmin=None,\n    vmax=None,\n    extent=None,\n    **kwargs,\n):\n\"\"\"\n    Plot a 2D line-of-sight table with facet slope vs facet azimuth.\n\n    Parameters:\n        table (ndarray): A 2D array of slope vs azimuth.\n        cmap_r (bool, optional): Use a reverse colormap. Default is False.\n        clabel (str, optional): Label for the colorbar. Default is an empty\n            string.\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. If not provided, \n            a new Axes object will be generated.\n        proj (str, optional): The projection to use. Valid values are 'polar'\n            and None. Default is None.\n        vmin (float, optional): The minimum value for the colorbar. Default is\n            None.\n        vmax (float, optional): The maximum value for the colorbar. Default is\n            None.\n    \"\"\"\n    if ax is not None and proj is not None and ax.name != proj:\n        msg = f\"Ax type {ax.name} must match projection, {proj}.\"\n        raise ValueError(msg)\n    if ax is None:\n        _, ax = plt.subplots(figsize=(6, 6), subplot_kw={\"projection\": proj})\n    if title is None:\n        title = \"Facet Slope vs. Azimuth\"\n    if vmin is None:\n        vmin = np.nanmin(table)\n    if vmax is None:\n        vmax = np.nanmax(table)\n    if extent is None:\n        extent = (0, 90, 360, 0)\n    if isinstance(table, (xr.DataArray, xr.Dataset)):\n        table = table.transpose(\"az\", \"theta\")\n        extent = (\n            table.theta.min(),\n            table.theta.max(),\n            table.az.min(),\n            table.az.max(),\n        )\n\n    if proj == \"polar\":\n        # Define polar coords R ~ slope, Theta ~ azimuth\n        r = np.linspace(*extent[:2], table.shape[1])\n        theta = np.linspace(*extent[2:], table.shape[0])\n        R, Theta = np.meshgrid(r, theta)\n        p = ax.pcolormesh(\n            np.deg2rad(Theta),\n            R,\n            table,\n            cmap=CMAP_R if cmap_r else CMAP,\n            vmin=vmin,\n            vmax=vmax,\n            shading=\"auto\",\n            rasterized=True,\n            **kwargs,\n        )\n        ax.set_theta_zero_location(\"N\")\n        ax.set_theta_direction(-1)\n        ax.set_rlabel_position(15)\n        ax.grid(\"on\", lw=0.1, c=\"k\")\n        ax.figure.colorbar(p, ax=ax, shrink=0.8, label=clabel)\n    else:\n        p = ax.imshow(\n            table,\n            extent=extent,\n            aspect=(extent[1] - extent[0]) / (extent[3] - extent[2]),\n            cmap=CMAP_R if cmap_r else CMAP,\n            vmin=vmin,\n            vmax=vmax,\n            interpolation=\"none\",\n            **kwargs,\n        )\n        ax.set_xlabel(\"Facet slope angle [deg]\")\n        ax.set_ylabel(\"Facet azimuth angle [deg]\")\n        ax.figure.colorbar(p, ax=ax, shrink=0.8, label=clabel)\n    ax.set_title(title)\n    return p\n</code></pre>"},{"location":"reference/roughness/","title":"roughness","text":"<p>Init roughness.</p>"}]}